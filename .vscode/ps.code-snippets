{
  "eraseable_pq.cpp": {
    "prefix": "eraseable_pq.cpp",
    "body": [
      "template <typename T, typename comp = less<T>>",
      "class eraseable_pq {",
      "  priority_queue<T, vector<T>, comp> pq, del;",
      "",
      "  void flush() {",
      "    while(del.size() && pq.top() == del.top()) {",
      "      pq.pop();",
      "      del.pop();",
      "    }",
      "  }",
      "public:",
      "  eraseable_pq() {}",
      "  size_t size() { return pq.size() - del.size(); };",
      "  void insert(T v) { pq.push(v); flush(); }",
      "  void erase(T v) { del.push(v); flush(); }",
      "  void pop() { del.pop(); flush(); }",
      "  const T& top() { return pq.top(); }",
      "};"
    ],
    "description": "eraseable_pq.cpp template"
  },
  "radix_sort.cpp": {
    "prefix": "radix_sort.cpp",
    "body": [
      "template <typename I>",
      "void radix_sort(I s, I e) {",
      "  for(int t = 0;t < 32;t += 8) {",
      "    queue<int> q[256];",
      "    for(I i = s;i != e;i++) q[((*i) >> t) & 255].push(*i);",
      "    I cur = s;",
      "    for(int i = 0;i < 256;i++) while(q[i].size()) {",
      "      *cur++ = q[i].front();",
      "      q[i].pop();",
      "    }",
      "  }",
      "}"
    ],
    "description": "radix_sort.cpp template"
  },
  "trie-for_xor.cpp": {
    "prefix": "trie-for_xor.cpp",
    "body": [
      "class trie {",
      "public:",
      "  trie* arr[2];",
      "  int cnt = 0;",
      "",
      "  trie() {",
      "    arr[0] = arr[1] = nullptr;",
      "  }",
      "  ~trie() {",
      "    delete arr[0];",
      "    delete arr[1];",
      "  }",
      "",
      "  void insert(int x, int delta) {",
      "    trie* cur = this;",
      "    cur->cnt += delta;",
      "    for(int i = 30;i >= 0;i--) {",
      "      bool bit = (x >> i) & 1;",
      "      if(!cur->arr[bit]) cur->arr[bit] = new trie();",
      "      cur = cur->arr[bit];",
      "      cur->cnt += delta;",
      "    }",
      "  }",
      "} root;",
      "",
      "// x와 xor했을 때의 최댓값",
      "int max(int x) {",
      "  int tmp = 0;",
      "  trie* cur = &root;",
      "  for(int i = 30;i >= 0;i--) {",
      "    bool bit = x >> i & 1;",
      "    if(cur->arr[!bit] && cur->arr[!bit]->cnt > 0) {",
      "      tmp |= (1 << j);",
      "      cur = cur->arr[!bit];",
      "    } else cur = cur->arr[bit];",
      "  }",
      "  return tmp;",
      "}",
      "",
      "// x와 xor했을 때 k 미만인 경우의 수",
      "int cnt(int x, int k) {",
      "  int tmp = 0;",
      "  trie *cur = &root;",
      "  for(int i = 30;i >= 0;i--) {",
      "    bool bit = x >> i & 1;",
      "    if(k >> i & 1) {",
      "      if(cur->arr[bit]) tmp += cur->arr[bit]->cnt;",
      "      if(cur->arr[!bit]) cur = cur->arr[!bit];",
      "      else break;",
      "    } else if(cur->arr[bit]) cur = cur->arr[bit];",
      "    else break;",
      "  }",
      "  return tmp;",
      "}"
    ],
    "description": "trie-for_xor.cpp template"
  },
  "union_find.cpp": {
    "prefix": "union_find.cpp",
    "body": [
      "class union_find {",
      "  const int sz;",
      "  vector<int> pa;",
      "",
      "public:",
      "  union_find(int n) : sz(n + 1), pa(sz, -1) {}",
      "",
      "  int find(int i) { return pa[i] < 0 ? i : pa[i] = find(pa[i]); }",
      "  bool merge(int a, int b) {",
      "    a = find(a), b = find(b);",
      "    if(a == b) return false;",
      "    if(-pa[a] < -pa[b]) swap(a, b);",
      "    pa[a] += pa[b];",
      "    pa[b] = a;",
      "    return true;",
      "  }",
      "  bool same(int a, int b) { return find(a) == find(b); }",
      "};",
      "",
      "// direction defined",
      "class union_find {",
      "  const int sz;",
      "  vector<int> pa;",
      "",
      "public:",
      "  union_find(int n) : sz(n + 1), pa(sz, -1) {}",
      "",
      "  int find(int i) { return pa[i] < 0 ? i : pa[i] = find(pa[i]); }",
      "  bool merge(int a, int b) {",
      "    a = find(a), b = find(b);",
      "    if(a == b) return false;",
      "    pa[b] = a;",
      "    return true;",
      "  }",
      "  bool same(int a, int b) { return find(a) == find(b); }",
      "};"
    ],
    "description": "union_find.cpp template"
  },
  "convex_hull.cpp": {
    "prefix": "convex_hull.cpp",
    "body": [
      "polygon convex_hull(polygon& poly) {",
      "  polygon tmp;",
      "  swap(poly[0], *min_element(poly.begin(), poly.end()));",
      "  sort(++poly.begin(), poly.end(), [&](point a, point b) {",
      "    int w = ccw(poly[0], a, b);",
      "    if(w) return w > 0;",
      "    return (poly[0] - a).size() < (poly[0] - b).size();",
      "  });",
      "  tmp.push_back(poly[0]);",
      "  tmp.push_back(poly[1]);",
      "  for(int i = 2;i < poly.size();i++) {",
      "    while(tmp.size() >= 2) {",
      "      point cur = tmp.back();",
      "      tmp.pop_back();",
      "      if(ccw(tmp.back(), cur, poly[i]) > 0) {",
      "        tmp.push_back(cur);",
      "        break;",
      "      }",
      "    }",
      "    tmp.push_back(poly[i]);",
      "  }",
      "  return tmp;",
      "}"
    ],
    "description": "convex_hull.cpp template"
  },
  "point_in_polygon.cpp": {
    "prefix": "point_in_polygon.cpp",
    "body": [
      "bool point_in_polygon(polygon& poly, point cur) {",
      "  int cnt = 0;",
      "  for(int i = 0;i < poly.size();i++) {",
      "    point p1 = poly[i], p2 = poly[(i + 1) % poly.size()];",
      "    if(p1.y > p2.y) swap(p1, p2);",
      "    if(ccw(p1, cur, p2) == 0 && p1.y <= cur.y && cur.y <= p2.y && min(p1.x, p2.x) <= cur.x && cur.x <= max(p1.x, p2.x)) return true;",
      "    if(p1.y <= cur.y && cur.y < p2.y && ccw(p1, p2, cur) > 0) cnt++;",
      "  }",
      "  return cnt % 2;",
      "}",
      "",
      "bool point_in_convex_polygon(polygon& poly, point cur) {",
      "  if(ccw(poly[0], poly[1], cur) < 0) return false;",
      "  int l = 1, r = poly.size() - 1;",
      "  while(l < r) {",
      "    int m = (l + r + 1) / 2;",
      "    if(ccw(poly[0], poly[m], cur) >= 0) l = m;",
      "    else r = m - 1;",
      "  }",
      "  if(l == poly.size() - 1) return ccw(poly[0], poly.back(), cur) == 0 && poly[0] <= cur && cur <= poly.back();",
      "  return ccw(poly[0], poly[1], cur) >= 0 && ccw(poly[l], poly[l + 1], cur) >= 0 && ccw(poly[l + 1], poly[0], cur) >= 0;",
      "}"
    ],
    "description": "point_in_polygon.cpp template"
  },
  "polygon_area.cpp": {
    "prefix": "polygon_area.cpp",
    "body": [
      "ll area2(polygon& poly) {",
      "  ll tmp = 0;",
      "  for(int i = 0;i < poly.size();i++) {",
      "    point bef = i ? poly[i - 1] : poly.back();",
      "    tmp += (ll)bef.x * poly[i].y - (ll)bef.y * poly[i].x;",
      "  }",
      "  return abs(tmp);",
      "}"
    ],
    "description": "polygon_area.cpp template"
  },
  "rotating_calipers.cpp": {
    "prefix": "rotating_calipers.cpp",
    "body": [
      "pair<point, point> rotating_calipers(polygon& poly) {",
      "  int sz = poly.size();",
      "  pair<ll, pair<point, point>> tmp = {dist2(poly[0] - poly[1]), {poly[0], poly[1]}};",
      "  for(int i = 0, j = 0;i < sz;i++) {",
      "    while(j < sz * 2 && ccw(poly[i], poly[(i + 1) % sz], poly[(i + 1) % sz] + poly[(j + 1) % sz] - poly[j % sz]) > 0) {",
      "      tmp = max(tmp, {dist2(poly[i] - poly[j % sz]), {poly[i], poly[j % sz]}});",
      "      j = (j + 1) % sz;",
      "    }",
      "    tmp = max(tmp, {dist2(poly[i] - poly[j % sz]), {poly[i], poly[j % sz]}});",
      "  }",
      "  return tmp.second;",
      "};",
      "",
      "ll rotating_calipers(polygon& poly) {",
      "  int sz = poly.size();",
      "  ll tmp = dist2(poly[0] - poly[1]);",
      "  for(int i = 0, j = 0;i < sz;i++) {",
      "    while(j < sz * 2 && ccw(poly[i], poly[(i + 1) % sz], poly[(i + 1) % sz] + poly[(j + 1) % sz] - poly[j % sz]) > 0) {",
      "      tmp = max(tmp, dist2(poly[i] - poly[j % sz]));",
      "      j = (j + 1) % sz;",
      "    }",
      "    tmp = max(tmp, dist2(poly[i] - poly[j % sz]));",
      "  }",
      "  return tmp;",
      "};"
    ],
    "description": "rotating_calipers.cpp template"
  },
  "ett.cpp": {
    "prefix": "ett.cpp",
    "body": [
      "int in[100005], out[100005];",
      "",
      "void ett(int cur) {",
      "  in[cur] = ++ettn;",
      "  for(int i : raw[cur]) if(!in[i]) ett(i);",
      "  out[cur] = ettn;",
      "}",
      "",
      "int arr[200005], in[100005], out[100005];",
      "",
      "void ett(int cur, int pa) {",
      "  arr[ettn] = cur;",
      "  in[cur] = ettn++;",
      "  for(int i : raw[cur]) if(i != pa) ett(i, cur);",
      "  arr[ettn] = cur;",
      "  out[cur] = ettn++;",
      "}",
      "",
      "void ett(int cur, int pa) {",
      "  arr[ettn] = cur;",
      "  cnt[cur][0]++;",
      "  in[cur] = ettn++;",
      "  for(int i : raw[cur]) if(i != pa) {",
      "    ett(i, cur);",
      "    arr[ettn++] = cur;",
      "    cnt[cur][0]++;",
      "  }",
      "  arr[ettn] = cur;",
      "  cnt[cur][0]++;",
      "  out[cur] = ettn++;",
      "}"
    ],
    "description": "ett.cpp template"
  },
  "lca.cpp": {
    "prefix": "lca.cpp",
    "body": [
      "class lowest_common_ancestor {",
      "  const int sz;",
      "  vector<int> weight, dep, pa, top;",
      "  vector<vector<int>> edges;",
      "",
      "public:",
      "  lowest_common_ancestor(int n) : sz(n + 1), ",
      "    weight(sz), dep(sz), pa(sz), top(sz),",
      "    edges(sz) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init(int root) {",
      "    function<void(int, int)> dfs = [&](int cur, int bef) {",
      "      weight[cur] = 1;",
      "      dep[cur] = dep[bef] + 1;",
      "      pa[cur] = bef;",
      "      for(int& i : edges[cur]) if(i != bef) {",
      "        dfs(i, cur);",
      "        weight[cur] += weight[i];",
      "        if(weight[i] > weight[edges[cur][0]]) swap(i, edges[cur][0]);",
      "      }",
      "    };",
      "    dfs(root, 0);",
      "    function <void(int, int)> ett = [&](int cur, int bef) {",
      "      for(int i : edges[cur]) if(i != bef) {",
      "        top[i] = i == edges[cur][0] ? top[cur] : i;",
      "        ett(i, cur);",
      "      }",
      "    };",
      "    top[root] = 1;",
      "    ett(root, 0);",
      "  }",
      "",
      "  int operator() (int a, int b) {",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "    }",
      "    return dep[a] < dep[b] ? a : b;",
      "  }",
      "};"
    ],
    "description": "lca.cpp template"
  },
  "scc.cpp": {
    "prefix": "scc.cpp",
    "body": [
      "// dag",
      "class strongly_connected_component {",
      "  const int sz;",
      "  vector<vector<int>> edges;",
      "  vector<int> idx;",
      "",
      "public:",
      "  vector<vector<int>> scc, dag;",
      "",
      "  strongly_connected_component(int n) : sz(n + 1), edges(sz), idx(sz, -1) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    vector<int> pa(sz, -1);",
      "    vector<bool> finished(sz);",
      "    stack<int> st;",
      "    int cnt = 0;",
      "    function<int(int)> dfs = [&](int cur) {",
      "      st.push(cur);",
      "      int bef = pa[cur] = ++cnt;",
      "      for(int i : edges[cur]) {",
      "        if(pa[i] == -1) bef = min(bef, dfs(i));",
      "        else if(!finished[i]) bef = min(bef, pa[i]);",
      "      }",
      "      if(bef == pa[cur]) {",
      "        scc.push_back({});",
      "        while(1) {",
      "          int i = st.top();",
      "          st.pop();",
      "          scc.back().push_back(i);",
      "          finished[i] = true;",
      "          idx[i] = scc.size() - 1;",
      "          if(cur == i) break;",
      "        }",
      "        sort(scc.back().begin(), scc.back().end());",
      "      }",
      "      return bef;",
      "    };",
      "    for(int i = 1;i < sz;i++) if(pa[i] == -1) dfs(i);",
      "    dag.resize(scc.size());",
      "    for(int i = 1;i < sz;i++) for(int j : edges[i]) if(idx[i] != idx[j]) dag[idx[i]].push_back(idx[j]);",
      "    for(auto& i : dag) {",
      "      sort(i.begin(), i.end());",
      "      i.erase(unique(i.begin(), i.end()), i.end());",
      "    }",
      "  }",
      "",
      "  int operator[] (int i) { return idx[i]; }",
      "};",
      "",
      "// short ver",
      "class strongly_connected_component {",
      "  const int sz;",
      "  vector<vector<int>> edges;",
      "  vector<int> idx;",
      "  int scc = 0;",
      "",
      "public:",
      "",
      "  strongly_connected_component(int n) : sz(n + 1), edges(sz), idx(sz, -1) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    vector<int> pa(sz, -1);",
      "    vector<bool> finished(sz);",
      "    stack<int> st;",
      "    int cnt = 0;",
      "    function<int(int)> dfs = [&](int cur) {",
      "      st.push(cur);",
      "      int bef = pa[cur] = ++cnt;",
      "      for(int i : edges[cur]) {",
      "        if(pa[i] == -1) bef = min(bef, dfs(i));",
      "        else if(!finished[i]) bef = min(bef, pa[i]);",
      "      }",
      "      if(bef == pa[cur]) {",
      "        scc++;",
      "        while(1) {",
      "          int i = st.top();",
      "          st.pop();",
      "          finished[i] = true;",
      "          idx[i] = scc - 1;",
      "          if(cur == i) break;",
      "        }",
      "      }",
      "      return bef;",
      "    };",
      "    for(int i = 1;i < sz;i++) if(pa[i] == -1) dfs(i);",
      "  }",
      "",
      "  int operator[] (int i) { return idx[i]; }",
      "};"
    ],
    "description": "scc.cpp template"
  },
  "static_graph.cpp": {
    "prefix": "static_graph.cpp",
    "body": [
      "//TODO",
      "",
      "template <typename T>",
      "class static_graph {",
      "  struct edge {",
      "    int u;",
      "    T v;",
      "    edge() = default;",
      "    edge(int u, T& v) : u(u), v(v) {}",
      "    operator int() const { return u; }",
      "  };",
      "  struct edges {",
      "    using I = vector<edge>::const_iterator;",
      "    I s, e;",
      "    I begin() { return s; }",
      "    I end() { return e; }",
      "    size_t size() { return e - s; }",
      "    decltype(auto) operator[] (int i) { return s[i]; }",
      "  };",
      "",
      "  const int n, m;",
      "  vector<int> cnt;",
      "  vector<pair<int, edge>> raw;",
      "  vector<edge> arr;",
      "",
      "public:",
      "  static_graph(int n, int m) : n(n), m(m), cnt(n + 2), arr(m) {",
      "    raw.reserve(m);",
      "  }",
      "",
      "  template <typename... Args>",
      "  void add(int u, Args&&... args) {",
      "    raw.emplace_back(u, edge{forward<Args>(args)...});",
      "    cnt[u]++;",
      "    if(raw.size() == m) {",
      "      for(int i = 1;i < cnt.size();i++) cnt[i] += cnt[i - 1];",
      "      for(auto& [u, v] : raw) arr[--cnt[u]] = v;",
      "      raw.clear();",
      "    }",
      "  }",
      "",
      "  edges operator[] (int i) {",
      "    return {arr.begin() + cnt[i], arr.begin() + cnt[i + 1]};",
      "  }",
      "};",
      "",
      "class static_graph {",
      "  struct edge {",
      "    int u;",
      "    edge() = default;",
      "    edge(int u) : u(u) {}",
      "    operator int() const { return u; }",
      "  };",
      "  struct edges {",
      "    using I = vector<edge>::const_iterator;",
      "    I s, e;",
      "    I begin() { return s; }",
      "    I end() { return e; }",
      "    size_t size() { return e - s; }",
      "    decltype(auto) operator[] (int i) { return s[i]; }",
      "  };",
      "",
      "  const int n, m;",
      "  vector<int> cnt;",
      "  vector<pair<int, edge>> raw;",
      "  vector<edge> arr;",
      "",
      "public:",
      "  static_graph(int n, int m) : n(n), m(m), cnt(n + 2), arr(m) {",
      "    raw.reserve(m);",
      "  }",
      "",
      "  void add(int u, int v) {",
      "    raw.emplace_back(u, v);",
      "    cnt[u]++;",
      "    if(raw.size() == m) {",
      "      for(int i = 1;i < cnt.size();i++) cnt[i] += cnt[i - 1];",
      "      for(auto& [u, v] : raw) arr[--cnt[u]] = v;",
      "      raw.clear();",
      "    }",
      "  }",
      "",
      "  edges operator[] (int i) {",
      "    return {arr.begin() + cnt[i], arr.begin() + cnt[i + 1]};",
      "  }",
      "};"
    ],
    "description": "static_graph.cpp template"
  },
  "two_sat.cpp": {
    "prefix": "two_sat.cpp",
    "body": [
      "class two_sat {",
      "  const int sz;",
      "  strongly_connected_component scc;",
      "  vector<char> ans;",
      "",
      "public:",
      "  two_sat(int n) : sz(n + 1), scc(sz * 2 + 1), ans(sz * 2 + 1, -1) {}",
      "",
      "  void add(int a, int b) {",
      "    if(a > 0) a = a * 2;",
      "    else a = -a * 2 + 1;",
      "    if(b > 0) b = b * 2;",
      "    else b = -b * 2 + 1;",
      "    scc.add(a ^ 1, b);",
      "    scc.add(b ^ 1, a);",
      "  }",
      "",
      "  bool operator() () {",
      "    bool flag = true;",
      "    scc.init();",
      "    for(int i = 1;i < sz && flag;i++) flag &= scc[i * 2] != scc[i * 2 + 1];",
      "    if(flag) {",
      "      vector<pair<int, int>> arr(sz * 2 - 2);",
      "      for(int i = 1;i < sz;i++) {",
      "        arr[i * 2 - 2] = {scc[i * 2], i * 2};",
      "        arr[i * 2 - 1] = {scc[i * 2 + 1], i * 2 + 1};",
      "      }",
      "      sort(arr.rbegin(), arr.rend());",
      "      for(auto [_, a] : arr) if(ans[a] == -1) {",
      "        ans[a] = 0;",
      "        ans[a ^ 1] = 1;",
      "      }",
      "    }",
      "    return flag;",
      "  }",
      "",
      "  bool operator[] (int i) { return ans[i * 2]; }",
      "};",
      "",
      "//short ver",
      "class two_sat {",
      "  const int sz;",
      "  strongly_connected_component scc;",
      "",
      "public:",
      "  two_sat(int n) : sz(n + 1), scc(sz * 2 + 1) {}",
      "",
      "  void add(int a, int b) {",
      "    if(a > 0) a = a * 2;",
      "    else a = -a * 2 + 1;",
      "    if(b > 0) b = b * 2;",
      "    else b = -b * 2 + 1;",
      "    scc.add(a ^ 1, b);",
      "    scc.add(b ^ 1, a);",
      "  }",
      "",
      "  bool operator() () {",
      "    bool flag = true;",
      "    scc.init();",
      "    for(int i = 1;i < sz && flag;i++) flag &= scc[i * 2] != scc[i * 2 + 1];",
      "    return flag;",
      "  }",
      "};"
    ],
    "description": "two_sat.cpp template"
  },
  "bipartite_match-Hopcroft_Karp.cpp": {
    "prefix": "bipartite_match-Hopcroft_Karp.cpp",
    "body": [
      "class bit_match {",
      "  const int l, r;",
      "  vector<vector<int>> edges;",
      "",
      "public:",
      "  bit_match(int l, int r) : l(l), r(r), edges(l) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  int operator() () {",
      "    int ret = 0;",
      "    vector<int> idx_l(l, -1), idx_r(r, -1);",
      "    while(1) {",
      "      vector<int> level(l, -1);",
      "      queue<int> q;",
      "      for(int i = 0;i < l;i++) if(idx_l[i] == -1) {",
      "        level[i] = 0;",
      "        q.push(i);",
      "      }",
      "      bool flag = false;",
      "      while(q.size()) {",
      "        int cur = q.front();",
      "        q.pop();",
      "        for(int i : edges[cur]) {",
      "          if(idx_r[i] == -1) flag = true;",
      "          else if(level[idx_r[i]] == -1) {",
      "            level[idx_r[i]] = level[cur] + 1;",
      "            q.push(idx_r[i]);",
      "          }",
      "        }",
      "      }",
      "      if(!flag) break;",
      "      function<bool(int)> dfs = [&](int cur) {",
      "        for(int i : edges[cur]) if(idx_r[i] == -1 || level[idx_r[i]] == level[cur] + 1 && dfs(idx_r[i])) {",
      "          idx_l[cur] = i;",
      "          idx_r[i] = cur;",
      "          return true;",
      "        }",
      "        return false;",
      "      };",
      "      for(int i = 0;i < l;i++) if(idx_l[i] == -1 && dfs(i)) ret++;",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ],
    "description": "bipartite_match-Hopcroft_Karp.cpp template"
  },
  "bipartite_match-Hungarian.cpp": {
    "prefix": "bipartite_match-Hungarian.cpp",
    "body": [
      "class bit_match {",
      "  const int l, r;",
      "  vector<vector<int>> edges;",
      "",
      "public:",
      "  bit_match(int l, int r) : l(l), r(r), edges(l) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  int operator() () {",
      "    int ret = 0;",
      "    vector<bool> visited(l);",
      "    vector<int> idx(r, -1);",
      "    function<bool(int)> dfs = [&](int cur) {",
      "      visited[cur] = true;",
      "      for(int i : edges[cur]) if(idx[i] == -1) {",
      "        idx[i] = cur;",
      "        return true;",
      "      }",
      "      for(int i : edges[cur]) if(idx[i] != -1 && !visited[idx[i]] && dfs(idx[i])) {",
      "        idx[i] = cur;",
      "        return true;",
      "      }",
      "      return false;",
      "    };",
      "    for(int i = 0;i < l;i++) {",
      "      visited.assign(l, 0);",
      "      ret += dfs(i);",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ],
    "description": "bipartite_match-Hungarian.cpp template"
  },
  "hld-lazy.cpp": {
    "prefix": "hld-lazy.cpp",
    "body": [
      "template <typename T, typename L, typename Merge, typename Update, typename Composition>",
      "class heavy_light_decomposition {",
      "  const int sz;",
      "  const T raw;",
      "  const L lazy_raw;",
      "  vector<int> weight, dep, pa, top, in;",
      "  vector<vector<int>> edges;",
      "  lazy_segment_tree<T, L, Merge, Update, Composition> seg;",
      "  Merge op;",
      "",
      "public:",
      "  heavy_light_decomposition(int n, T raw, L lazy_raw) : sz(n + 1), raw(raw), lazy_raw(lazy_raw),",
      "    weight(sz), dep(sz), pa(sz), top(sz), in(sz),",
      "    edges(sz), seg(sz, raw, lazy_raw) {",
      "    for(int i = 0;i < sz;i++) seg.set(i, 1e9);",
      "    seg.init();",
      "  }",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    function<void(int, int)> dfs = [&](int cur, int bef) {",
      "      weight[cur] = 1;",
      "      dep[cur] = dep[bef] + 1;",
      "      pa[cur] = bef;",
      "      for(int& i : edges[cur]) if(i != bef) {",
      "        dfs(i, cur);",
      "        weight[cur] += weight[i];",
      "        if(weight[i] > weight[edges[cur][0]]) swap(i, edges[cur][0]);",
      "      }",
      "    };",
      "    dfs(1, 0);",
      "    int ettn = 0;",
      "    function <void(int, int)> ett = [&](int cur, int bef) {",
      "      in[cur] = ettn++;",
      "      for(int i : edges[cur]) if(i != bef) {",
      "        top[i] = i == edges[cur][0] ? top[cur] : i;",
      "        ett(i, cur);",
      "      }",
      "    };",
      "    top[1] = 1;",
      "    ett(1, 0);",
      "  }",
      "",
      "  void update(int a, int b, L v) {",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      seg.update(in[top[a]], in[a], v);",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    seg.update(in[a], in[b], v);",
      "    // seg.update(in[a] + 1, in[b], v); 간선",
      "  }",
      "",
      "  T operator() (int a, int b) {",
      "    T s = raw;",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      s = op(s, seg(in[top[a]], in[a]));",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    return op(s, seg(in[a], in[b]));",
      "    // return op(s, seg(in[a] + 1, in[b])); 간선",
      "  }",
      "};"
    ],
    "description": "hld-lazy.cpp template"
  },
  "hld-lazy_basic.cpp": {
    "prefix": "hld-lazy_basic.cpp",
    "body": [
      "template <typename T>",
      "class heavy_light_decomposition {",
      "  const int sz;",
      "  vector<int> weight, dep, pa, top, in;",
      "  vector<vector<int>> edges;",
      "  lazy_fenwick_tree<T> seg;",
      "",
      "public:",
      "  heavy_light_decomposition(int n) : sz(n + 1),",
      "    weight(sz), dep(sz), pa(sz), top(sz), in(sz),",
      "    edges(sz), seg(sz) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    function<void(int, int)> dfs = [&](int cur, int bef) {",
      "      weight[cur] = 1;",
      "      dep[cur] = dep[bef] + 1;",
      "      pa[cur] = bef;",
      "      for(int& i : edges[cur]) if(i != bef) {",
      "        dfs(i, cur);",
      "        weight[cur] += weight[i];",
      "        if(weight[i] > weight[edges[cur][0]]) swap(i, edges[cur][0]);",
      "      }",
      "    };",
      "    dfs(1, 0);",
      "    int ettn = 0;",
      "    function <void(int, int)> ett = [&](int cur, int bef) {",
      "      in[cur] = ettn++;",
      "      for(int i : edges[cur]) if(i != bef) {",
      "        top[i] = i == edges[cur][0] ? top[cur] : i;",
      "        ett(i, cur);",
      "      }",
      "    };",
      "    top[1] = 1;",
      "    ett(1, 0);",
      "  }",
      "",
      "  void update(int a, int b, T v) {",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      seg.update(in[top[a]], in[a], v);",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    seg.update(in[a] + 1, in[b], v);",
      "  }",
      "",
      "  T operator() (int a, int b) {",
      "    T s = 0;",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      s += seg(in[top[a]], in[a]);",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    return s + seg(in[a] + 1, in[b]);",
      "  }",
      "};"
    ],
    "description": "hld-lazy_basic.cpp template"
  },
  "hld-subtree_and_path.cpp": {
    "prefix": "hld-subtree_and_path.cpp",
    "body": [
      "template <typename T, typename L, typename Merge, typename Update, typename Composition>",
      "class heavy_light_decomposition {",
      "  const int sz;",
      "  const T raw;",
      "  const L lazy_raw;",
      "  vector<int> weight, dep, pa, top, in, out;",
      "  vector<vector<int>> edges;",
      "  lazy_segment_tree<T, L, Merge, Update, Composition> seg;",
      "  Merge op;",
      "",
      "public:",
      "  heavy_light_decomposition(int n, T raw, L lazy_raw) : sz(n + 1), raw(raw), lazy_raw(lazy_raw),",
      "    weight(sz), dep(sz), pa(sz), top(sz), in(sz), out(sz),",
      "    edges(sz), seg(sz, raw, lazy_raw) {",
      "    for(int i = 0;i < sz;i++) seg.set(i, {0, 1});",
      "    seg.init();",
      "  }",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    function<void(int, int)> dfs = [&](int cur, int bef) {",
      "      weight[cur] = 1;",
      "      dep[cur] = dep[bef] + 1;",
      "      pa[cur] = bef;",
      "      for(int& i : edges[cur]) if(i != bef) {",
      "        dfs(i, cur);",
      "        weight[cur] += weight[i];",
      "        if(weight[i] > weight[edges[cur][0]]) swap(i, edges[cur][0]);",
      "      }",
      "    };",
      "    dfs(1, 0);",
      "    int ettn = 0;",
      "    function <void(int, int)> ett = [&](int cur, int bef) {",
      "      in[cur] = ettn++;",
      "      for(int i : edges[cur]) if(i != bef) {",
      "        top[i] = i == edges[cur][0] ? top[cur] : i;",
      "        ett(i, cur);",
      "      }",
      "      out[cur] = ettn - 1;",
      "    };",
      "    top[1] = 1;",
      "    ett(1, 0);",
      "  }",
      "",
      "  void update(int a, L v) {",
      "    seg.update(in[a], out[a], v);",
      "  }",
      "  void update(int a, int b, L v) {",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      seg.update(in[top[a]], in[a], v);",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    seg.update(in[a], in[b], v);",
      "  }",
      "",
      "  T operator() (int a) {",
      "    return seg(in[a], out[a]);",
      "  }",
      "  T operator() (int a, int b) {",
      "    T s = raw;",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      s = op(s, seg(in[top[a]], in[a]));",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    return op(s, seg(in[a], in[b]));",
      "  }",
      "};"
    ],
    "description": "hld-subtree_and_path.cpp template"
  },
  "hld.cpp": {
    "prefix": "hld.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class heavy_light_decomposition {",
      "  const int sz;",
      "  const T raw;",
      "  vector<int> weight, dep, pa, top, in;",
      "  vector<vector<int>> edges;",
      "  segment_tree<T, Merge> seg;",
      "  Merge op;",
      "",
      "public:",
      "  heavy_light_decomposition(int n, T raw) : sz(n + 1), raw(raw),",
      "    weight(sz), dep(sz), pa(sz), top(sz), in(sz),",
      "    edges(sz), seg(sz, raw) {}",
      "",
      "  void add(int a, int b) {",
      "    edges[a].push_back(b);",
      "  }",
      "",
      "  void init() {",
      "    function<void(int, int)> dfs = [&](int cur, int bef) {",
      "      weight[cur] = 1;",
      "      dep[cur] = dep[bef] + 1;",
      "      pa[cur] = bef;",
      "      for(int& i : edges[cur]) if(i != bef) {",
      "        dfs(i, cur);",
      "        weight[cur] += weight[i];",
      "        if(weight[i] > weight[edges[cur][0]]) swap(i, edges[cur][0]);",
      "      }",
      "    };",
      "    dfs(1, 0);",
      "    int ettn = 0;",
      "    function <void(int, int)> ett = [&](int cur, int bef) {",
      "      in[cur] = ettn++;",
      "      for(int i : edges[cur]) if(i != bef) {",
      "        top[i] = i == edges[cur][0] ? top[cur] : i;",
      "        ett(i, cur);",
      "      }",
      "    };",
      "    top[1] = 1;",
      "    ett(1, 0);",
      "  }",
      "",
      "  void update(int a, int b, T v) {",
      "    if(dep[a] < dep[b]) swap(a, b);",
      "    seg.update(in[a], v);",
      "  }",
      "",
      "  T operator() (int a, int b) {",
      "    T s = raw;",
      "    for(;top[a] != top[b];a = pa[top[a]]) {",
      "      if(dep[top[a]] < dep[top[b]]) swap(a, b);",
      "      s = op(s, seg(in[top[a]], in[a]));",
      "    }",
      "    if(dep[a] > dep[b]) swap(a, b);",
      "    return op(s, seg(in[a], in[b]));",
      "    // return op(s, seg(in[a] + 1, in[b])); 간선",
      "  }",
      "};"
    ],
    "description": "hld.cpp template"
  },
  "max_flow-Dinic-bad.cpp": {
    "prefix": "max_flow-Dinic-bad.cpp",
    "body": [
      "class max_flow {",
      "  const int sz;",
      "  vector<vector<int>> edges, cap, flow;",
      "",
      "public:",
      "  max_flow(int sz) : sz(sz), edges(sz), cap(sz, vector<int>(sz)), flow(sz, vector<int>(sz)) {}",
      "",
      "  void add(int a, int b, int v, bool directed = true) {",
      "    edges[a].push_back(b);",
      "    edges[b].push_back(a);",
      "    cap[a][b] += v;",
      "    if(!directed) cap[b][a] += v;",
      "  }",
      "",
      "  int operator() (int s, int e) {",
      "    int ret = 0;",
      "    while(1) {",
      "      vector<int> level(sz, -1);",
      "      level[s] = 0;",
      "      queue<int> q;",
      "      q.push(s);",
      "      while(q.size()) {",
      "        int cur = q.front();",
      "        q.pop();",
      "        for(int i : edges[cur]) if(cap[cur][i] > flow[cur][i] && level[i] == -1) {",
      "          level[i] = level[cur] + 1;",
      "          q.push(i);",
      "        }",
      "      }",
      "      if(level[e] == -1) break;",
      "      vector<int> idx(sz);",
      "      function<int(int, int)> dfs = [&](int cur, int tmp) {",
      "        if(cur == e) return tmp;",
      "        for(int& i = idx[cur];i < edges[cur].size();i++) {",
      "          int j = edges[cur][i];",
      "          if(level[cur] + 1 == level[j] && cap[cur][j] > flow[cur][j]) {",
      "            int nxt = dfs(j, min(cap[cur][j] - flow[cur][j], tmp));",
      "            if(nxt) {",
      "              flow[cur][j] += nxt;",
      "              flow[j][cur] -= nxt;",
      "              return nxt;",
      "            }",
      "          }",
      "        }",
      "        return 0;",
      "      };",
      "      for(int i;i = dfs(s, INT_MAX);ret += i);",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ],
    "description": "max_flow-Dinic-bad.cpp template"
  },
  "max_flow-Dinic-optimized.cpp": {
    "prefix": "max_flow-Dinic-optimized.cpp",
    "body": [
      "class max_flow {",
      "  struct edge {",
      "    int loc, cap, flow, rev;",
      "  };",
      "",
      "  const int sz;",
      "  vector<vector<edge>> edges;",
      "",
      "public:",
      "  max_flow(int sz) : sz(sz), edges(sz) {}",
      "",
      "  void add(int a, int b, int cap, bool directed = true) {",
      "    edges[a].emplace_back(b, cap, 0, edges[b].size());",
      "    edges[b].emplace_back(a, directed ? 0 : cap, 0, edges[a].size() - 1);",
      "  }",
      "",
      "  int operator() (int s, int e) {",
      "    int ret = 0;",
      "    while(1) {",
      "      vector<int> level(sz, -1), idx(sz);",
      "      queue<int> q;",
      "      level[s] = 0;",
      "      q.push(s);",
      "      while(q.size() && level[e] == -1) {",
      "        int cur = q.front();",
      "        q.pop();",
      "        for(edge &i : edges[cur]) if(level[i.loc] == -1 && i.cap > i.flow) {",
      "          level[i.loc] = level[cur] + 1;",
      "          q.push(i.loc);",
      "        }",
      "      }",
      "      if(level[e] == -1) break;",
      "      function<int(int, int)> dfs = [&](int cur, int tmp) {",
      "        if(cur == e) return tmp;",
      "        for(int &i = idx[cur];i < edges[cur].size();i++) {",
      "          edge &j = edges[cur][i];",
      "          if(level[cur] + 1 == level[j.loc] && j.cap > j.flow) {",
      "            int nxt = dfs(j.loc, min(tmp, j.cap - j.flow));",
      "            if(nxt) {",
      "              j.flow += nxt;",
      "              edges[j.loc][j.rev].flow -= nxt;",
      "              return nxt;",
      "            }",
      "          }",
      "        }",
      "        return 0;",
      "      };",
      "      for(int i;i = dfs(s, INT_MAX);ret += i);",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ],
    "description": "max_flow-Dinic-optimized.cpp template"
  },
  "max_flow-Edmonds_Karp.cpp": {
    "prefix": "max_flow-Edmonds_Karp.cpp",
    "body": [
      "class max_flow {",
      "  const int sz;",
      "  vector<vector<int>> edges, cap, flow;",
      "",
      "public:",
      "  max_flow(int sz) : sz(sz), edges(sz), cap(sz, vector<int>(sz)), flow(sz, vector<int>(sz)) {}",
      "",
      "  void add(int a, int b, int v, bool directed = true) {",
      "    edges[a].push_back(b);",
      "    edges[b].push_back(a);",
      "    cap[a][b] += v;",
      "    if(!directed) cap[b][a] += v;",
      "  }",
      "",
      "  int operator() (int s, int e) {",
      "    int ret = 0;",
      "    while(1) {",
      "      vector<int> bef(sz, -1);",
      "      queue<int> q;",
      "      q.push(s);",
      "      while(q.size() && bef[e] == -1) {",
      "        int cur = q.front();",
      "        q.pop();",
      "        for(int i : edges[cur]) if(cap[cur][i] > flow[cur][i] && bef[i] == -1) {",
      "          bef[i] = cur;",
      "          q.push(i);",
      "        }",
      "      }",
      "      if(bef[e] == -1) break;",
      "      int tmp = INT_MAX;",
      "      for(int i = e;i != s;i = bef[i]) tmp = min(tmp, cap[bef[i]][i] - flow[bef[i]][i]);",
      "      for(int i = e;i != s;i = bef[i]) {",
      "        flow[bef[i]][i] += tmp;",
      "        flow[i][bef[i]] -= tmp;",
      "      }",
      "      ret += tmp;",
      "    }",
      "    return ret;",
      "  }",
      "};"
    ],
    "description": "max_flow-Edmonds_Karp.cpp template"
  },
  "max_flow-HLPP.cpp": {
    "prefix": "max_flow-HLPP.cpp",
    "body": [
      "class max_flow {",
      "  struct edge {",
      "    int loc, cap, flow, rev;",
      "  };",
      "",
      "  const int sz;",
      "  vector<vector<edge>> edges;",
      "  vector<stack<int>> level_list;",
      "  vector<int> excess, level;",
      "",
      "  void apply(edge& e, int flow) {",
      "    edge& rev = edges[e.loc][e.rev];",
      "    if (!excess[e.loc] && flow) level_list[level[e.loc]].push(e.loc);",
      "    e.flow += flow;",
      "    e.cap -= flow;",
      "    excess[e.loc] += flow;",
      "    rev.flow -= flow;",
      "    rev.cap += flow;",
      "    excess[rev.loc] -= flow;",
      "  }",
      "",
      "public:",
      "  max_flow(int n) : sz(n), edges(sz), excess(sz), level(sz), level_list(sz * 2) { }",
      "",
      "  void add(int a, int b, int cap, bool directed = true) {",
      "    edges[a].emplace_back(b, cap, 0, edges[b].size());",
      "    edges[b].emplace_back(a, directed ? 0 : cap, 0, edges[a].size() - 1);",
      "  }",
      "",
      "  int operator() (int s, int e) {",
      "    vector<int> cnt(sz * 2);",
      "    vector<edge*> ptr(sz);",
      "    level[s] = sz;",
      "    excess[e] = 1;",
      "    cnt[0] = sz - 1;",
      "    for(int i = 0;i < sz;i++) ptr[i] = edges[i].data();",
      "    for(edge &i : edges[s]) apply(i, i.cap);",
      "    for(int top = 0;;) {",
      "      while(level_list[top].empty()) if(!top--) return -excess[s];",
      "      int cur = level_list[top].top();",
      "      level_list[top].pop();",
      "      while(excess[cur] > 0) {",
      "        if(ptr[cur] == edges[cur].data() + edges[cur].size()) {",
      "          level[cur] = INT_MAX;",
      "          for(edge &i : edges[cur]) if(i.cap && level[cur] > level[i.loc] + 1) {",
      "            level[cur] = level[i.loc] + 1;",
      "            ptr[cur] = &i;",
      "          }",
      "          cnt[level[cur]]++;",
      "          cnt[top]--;",
      "          if(!cnt[top] && top < sz) for(int i = 0;i < sz;i++) if(top < level[i] && level[i] < sz) {",
      "            cnt[level[i]]--;",
      "            level[i] = sz + 1;",
      "          }",
      "          top = level[cur];",
      "        } else if(ptr[cur]->cap && level[cur] == level[ptr[cur]->loc] + 1) apply(*ptr[cur], min(excess[cur], ptr[cur]->cap));",
      "        else ptr[cur]++;",
      "      }",
      "    }",
      "  }",
      "",
      "  bool blocked(int a) {",
      "    return level[a] >= sz;",
      "  }",
      "};"
    ],
    "description": "max_flow-HLPP.cpp template"
  },
  "mcmf.cpp": {
    "prefix": "mcmf.cpp",
    "body": [
      "// TODO"
    ],
    "description": "mcmf.cpp template"
  },
  "combination.cpp": {
    "prefix": "combination.cpp",
    "body": [
      "using ll = long long;",
      "",
      "template <int sz, int mod = 1'000'000'007>",
      "class combination {",
      "  int fact[sz + 1], inv[sz + 1];",
      "",
      "  static constexpr int _pow(ll n, int exp) {",
      "    ll tmp = 1;",
      "    for(;exp;exp /= 2) {",
      "      if (exp & 1) tmp = tmp * n % mod;",
      "      n = (n * n) % mod;",
      "    }",
      "    return tmp;",
      "  }",
      "",
      "public:",
      "  constexpr combination() {",
      "    fact[0] = 1;",
      "    for(int i = 1;i <= sz;i++) fact[i] = (ll)fact[i - 1] * i % mod;",
      "    inv[sz] = _pow(fact[sz], mod - 2);",
      "    for(int i = sz;i;i--) inv[i - 1] = (ll)inv[i] * i % mod;",
      "  }",
      "",
      "  ll operator() (int n, int r) const {",
      "    return (ll)fact[n] * inv[r] % mod * inv[n - r] % mod;",
      "  }",
      "};"
    ],
    "description": "combination.cpp template"
  },
  "fft.cpp": {
    "prefix": "fft.cpp",
    "body": [
      "template<typename I>",
      "requires same_as<typename iterator_traits<I>::value_type, complex<double>>",
      "void fft(I s, I e, bool inv = false) {",
      "  int sz = distance(s, e);",
      "  assert((sz & (sz - 1)) == 0);",
      "  for(int i = 1, j = 0;i < sz;i++) {",
      "    int bit = sz / 2;",
      "    while(j >= bit) {",
      "      j -= bit;",
      "      bit /= 2;",
      "    }",
      "    j += bit;",
      "    if(i < j) swap(s[i], s[j]);",
      "  }",
      "  for(int k = 1;k < sz;k *= 2) {",
      "    double angle = inv ? numbers::pi / k : -numbers::pi / k;",
      "    complex<double> w(cos(angle), sin(angle));",
      "    for(int i = 0;i < sz;i += k * 2) {",
      "      complex<double> z(1, 0);",
      "      for(int j = 0;j < k;j++) {",
      "        complex<double> even = s[i + j], odd = s[i + j + k];",
      "        s[i + j] = even + z * odd;",
      "        s[i + j + k] = even - z * odd;",
      "        z *= w;",
      "      }",
      "    }",
      "  }",
      "  if(inv) while(s != e) *s++ /= sz;",
      "}",
      "",
      "vector<base> mul(vector<base> a, vector<base> b) {",
      "  int sz = 1;",
      "  while(sz < a.size() + b.size()) sz *= 2;",
      "",
      "  a.resize(sz); fft(a.begin(), a.end());",
      "  b.resize(sz); fft(b.begin(), b.end());",
      "",
      "  for(int i = 0;i < sz;i++) a[i] *= b[i];",
      "  fft(a.begin(), a.end(), true);",
      "",
      "  return a;",
      "}"
    ],
    "description": "fft.cpp template"
  },
  "fraction.cpp": {
    "prefix": "fraction.cpp",
    "body": [
      "class fraction {",
      "  ll n, d;",
      "public:",
      "  fraction(ll a = 0, ll b = 1) : n(a), d(b) {",
      "    assert(d != 0);",
      "    ll g = gcd(a, b);",
      "    n /= g;",
      "    d /= g;",
      "  }",
      "",
      "  fraction operator+ (fraction v) { return fraction(n * v.d + d * v.n, d * v.d); }",
      "  fraction operator+= (fraction v) { return *this + v; }",
      "  fraction operator- (fraction v) { return fraction(n * v.d - d * v.n, d * v.d); }",
      "  fraction operator-= (fraction v) { return *this - v; }",
      "  fraction operator* (fraction v) { return fraction(n * v.n, d * v.d); }",
      "  fraction operator*= (fraction v) { return *this * v; }",
      "  fraction operator/ (fraction v) { return fraction(n * v.d, d * v.n); }",
      "  fraction operator/= (fraction v) { return *this / v; }",
      "  fraction operator- () { return fraction(-n, d); }",
      "",
      "  strong_ordering operator<=> (fraction v) { return n * v.d <=> d * v.n; }",
      "",
      "  explicit operator bool() { return n != 0; }",
      "  explicit operator double() { return (double)n / d; }",
      "",
      "  friend ostream& operator<< (ostream& cout, fraction& v) { return cout << v.n << '/'<< v.d; }",
      "",
      "  friend ll floor(fraction v) { return v.n / v.d - ((v.n % v.d != 0) && ((v.n < 0) != (v.d < 0))); }",
      "  friend ll ceil(fraction v) { return v.n / v.d + ((v.n % v.d != 0) && ((v.n > 0) == (v.d > 0))); }",
      "  friend ll round(fraction v) { return (v.n + v.d / 2 * ((v.n > 0) == (v.d > 0))) / v.d; }",
      "  friend fraction abs(fraction v) { return fraction(abs(v.n), abs(v.d)); }",
      "",
      "  friend struct formatter<fraction>;",
      "};",
      "",
      "namespace std {",
      "  template <>",
      "  struct formatter<fraction> : formatter<string_view> {",
      "    auto format(fraction f, auto& ctx) {",
      "      return formatter<string_view>::format(",
      "        string_view(to_string(f.n) + \"/\" + to_string(f.d)),",
      "        ctx",
      "      );",
      "    }",
      "  };",
      "}"
    ],
    "description": "fraction.cpp template"
  },
  "matrix.cpp": {
    "prefix": "matrix.cpp",
    "body": [
      "template <typename T, int N, int M>",
      "struct matrix : array<array<T, M>, N> {",
      "  using super = array<array<T, M>, N>;",
      "",
      "  matrix() {",
      "    for(int i = 0;i < N;i++) super::operator[](i).fill(T());",
      "  }",
      "",
      "  matrix<T, N, M> operator+ (matrix<T, N, M>& v) {",
      "    matrix<T, N, M> tmp;",
      "    for(int i = 0;i < N;i++) for(int j = 0;j < M;j++) {",
      "      tmp[i][j] = (super::operator[](i)[j] + v[i][j]) % MOD;",
      "    }",
      "    return tmp;",
      "  }",
      "",
      "  template <int K>",
      "  matrix<T, N, K> operator* (matrix<T, M, K>& v) {",
      "    matrix<T, N, K> tmp;",
      "    for(int i = 0;i < N;i++) for(int j = 0;j < K;j++) for(int k = 0;k < M;k++) {",
      "      tmp[i][j] += super::operator[](i)[k] * v[k][j];",
      "    }",
      "    return tmp;",
      "  }",
      "};",
      "",
      "template <typename T, int N>",
      "matrix<T, N, N> pow(matrix<T, N, N> v, ll exp) {",
      "  matrix<T, N, N> tmp = v;",
      "  for(exp--;exp;exp /= 2) {",
      "    if(exp & 1) tmp = tmp * v;",
      "    v = v * v;",
      "  }",
      "  return tmp;",
      "}",
      "",
      "// f(n) = x * f(n - 1) + y * f(n - 2) (aka 피보나치 수열)",
      "/*",
      "a = |x y|, b = |f(1)|",
      "    |1 0|      |f(0)|",
      "*/",
      "ll fibo(ll n) {",
      "  matrix<ll, 2, 2> a;",
      "  matrix<ll, 2, 1> b;",
      "  a[0][0] = a[0][1] = a[1][0] = b[0][0] = 1;",
      "  return (pow(a, n) * b)[1][0];",
      "}",
      "",
      "template <typename T, int N, int M>",
      "istream& operator >> (istream& cin, matrix<T, N, M>& v) {",
      "  for(int i = 0;i < N;i++) for(int j = 0;j < M;j++) cin >> v[i][j];",
      "  return cin;",
      "}",
      "",
      "template <typename T, int N, int M>",
      "ostream& operator << (ostream& cout, matrix<T, N, M>& v) {",
      "  for(int i = 0;i < N;i++) for(int j = 0;j < M;j++) cout << v[i][j] << \" \\n\"[j + 1 == M];",
      "  return cout;",
      "}"
    ],
    "description": "matrix.cpp template"
  },
  "modint.cpp": {
    "prefix": "modint.cpp",
    "body": [
      "using ll = long long;",
      "",
      "template <int mod = 1'000'000'007>",
      "class modint {",
      "  ll val;",
      "",
      "  modint _pow(ll exp) const {",
      "    ll n = val, tmp = 1;",
      "    for(;exp;exp /= 2) {",
      "      if (exp & 1) tmp = tmp * n % mod;",
      "      n = (n * n) % mod;",
      "    }",
      "    return modint(tmp);",
      "  }",
      "",
      "  modint _inv() const {",
      "    return _pow(mod - 2);",
      "  }",
      "",
      "public:",
      "  modint(ll n = 0) : val((n %= mod) < 0 ? n + mod : n) {}",
      "",
      "  modint operator+ (const modint v) {",
      "    int tmp = val + v.val;",
      "    if(tmp >= mod) tmp -= mod;",
      "    return modint(tmp);",
      "  }",
      "  modint operator- (const modint v) {",
      "    int tmp = val + mod - v.val;",
      "    if(tmp >= mod) tmp -= mod;",
      "    return modint(tmp);",
      "  }",
      "  modint operator* (const modint v) { return modint(val * v.val % mod); }",
      "  modint operator/ (const modint v) { return *this * v._inv(); }",
      "  modint operator- () { return modint(val ? mod - val : val); }",
      "",
      "  bool operator! () { return val == 0; }",
      "  explicit operator bool() { return val != 0; }",
      "",
      "  friend istream& operator>> (istream& cin, modint& v) {",
      "    cin >> v.val;",
      "    if((v.val %= mod) < 0) v.val += mod;",
      "    return cin;",
      "  }",
      "  friend ostream& operator<< (ostream& cout, const modint v) {",
      "    cout << v.val;",
      "    return cout;",
      "  }",
      "};",
      "",
      "template <int mod = 1'000'000'007>",
      "modint<mod> comb(int n, int r) {",
      "  if(r > n - r) r = n - r;",
      "  modint<mod> x = 1, y = 1;",
      "  for(int i = 0;i < r;i++) {",
      "    x = x * (n - i);",
      "    y = y * (i + 1);",
      "  }",
      "  return x / y;",
      "}"
    ],
    "description": "modint.cpp template"
  },
  "polynomial.cpp": {
    "prefix": "polynomial.cpp",
    "body": [
      "struct polynomial : vector<complex<double>> {",
      "  using super = vector<complex<double>>;",
      "  using super::super;",
      "",
      "  polynomial operator* (polynomial v) {",
      "    const int sz = 1 << __lg(this->size() + v.size() - 1) + 1;",
      "    this->resize(sz); fft(this->begin(), this->end());",
      "    v.resize(sz); fft(v.begin(), v.end());",
      "    for(int i = 0;i < sz;i++) (*this)[i] *= v[i];",
      "    fft(this->begin(), this->end(), true);",
      "    return *this;",
      "  }",
      "};"
    ],
    "description": "polynomial.cpp template"
  },
  "pow.cpp": {
    "prefix": "pow.cpp",
    "body": [
      "ll _pow(ll n, ll exp, ll mod) {",
      "  ll tmp = 1;",
      "  for(;exp;exp /= 2) {",
      "    if(exp & 1) tmp = tmp * n % mod;",
      "    n = (n * n) % mod;",
      "  }",
      "  return tmp;",
      "}"
    ],
    "description": "pow.cpp template"
  },
  "steinhaus_johnson_trotter.cpp": {
    "prefix": "steinhaus_johnson_trotter.cpp",
    "body": [
      "template <typename I>",
      "class steinhaus_johnson_trotter {",
      "  const int n;",
      "  I s, e;",
      "  vector<char> dir;",
      "",
      "public:",
      "  steinhaus_johnson_trotter(I s, I e) : n(distance(s, e)), s(s), e(e), dir(n, -1) {",
      "    assert(is_sorted(s, e));",
      "  }",
      "",
      "  bool next() {",
      "    int n = distance(s, e);",
      "    int tmp = -1;",
      "    for(int i = 0;i < n;i++) {",
      "      int nxt = i + dir[i];",
      "      if(nxt < 0 || nxt >= n) continue;",
      "      if(s[i] > s[nxt] && (tmp == -1 || s[i] > s[tmp])) tmp = i;",
      "    }",
      "    if(tmp == -1) return false;",
      "    int nxt = tmp + dir[tmp];",
      "    for(int i = 0;i < n;i++) if(s[i] > s[nxt]) dir[i] *= -1;",
      "  }",
      "}",
      "",
      "//https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm"
    ],
    "description": "steinhaus_johnson_trotter.cpp template"
  },
  "miller_rabin.cpp": {
    "prefix": "miller_rabin.cpp",
    "body": [
      "ll _pow(__int128 n, ll exp, ll mod) {",
      "  __int128 tmp = 1;",
      "  for(n %= mod;exp;exp /= 2) {",
      "    if(exp & 1) tmp = tmp * n % mod;",
      "    n = (n * n) % mod;",
      "  }",
      "  return tmp;",
      "}",
      "",
      "bool miller_rabin(ll n) {",
      "  if(n == 1) return false;",
      "  if(n == 2) return true;",
      "  for(ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) if(a % n) {",
      "    for(ll k = n - 1;;k /= 2) {",
      "      ll tmp = _pow(a, k, n);",
      "      if(tmp == n - 1) break;",
      "      if(k % 2) {",
      "        if(tmp == 1) break;",
      "        else return false;",
      "      }",
      "    }",
      "  }",
      "  return true;",
      "}",
      "",
      "/*",
      "n <= 2^32 -> {2, 7, 61}",
      "n <= 2^64 -> {2, 325, 9375, 28178, 450775, 9780504, 1795265022}",
      "*/"
    ],
    "description": "miller_rabin.cpp template"
  },
  "pollard_rho.cpp": {
    "prefix": "pollard_rho.cpp",
    "body": [
      "vector<ll> pollard_rho(ll n) {",
      "  srand(time(nullptr));",
      "  vector<ll> tmp;",
      "  function<void(ll)> dfs = [&](ll n) {",
      "    if(n == 1) return;",
      "    if(miller_rabin(n)) {",
      "      tmp.push_back(n);",
      "      return;",
      "    }",
      "    while(1) {",
      "      ll c = rand() % (n - 2) + 1, x = rand() % (n - 2) + 1, y = x, d = 1;",
      "      auto f = [&](ll v) { return ((__int128)v * v + c) % n; };",
      "      while(d == 1) {",
      "        x = f(x);",
      "        y = f(f(y));",
      "        d = gcd(abs(x - y), n);",
      "      }",
      "      if(d != n) {",
      "        dfs(d);",
      "        dfs(n / d);",
      "        break;",
      "      }",
      "    }",
      "  };",
      "  for(;n % 2 == 0;n /= 2) tmp.push_back(2);",
      "  dfs(n);",
      "  sort(tmp.begin(), tmp.end());",
      "  return tmp;",
      "}"
    ],
    "description": "pollard_rho.cpp template"
  },
  "sieve.cpp": {
    "prefix": "sieve.cpp",
    "body": [
      "// segmented sieve",
      "template <ll n, int chunk>",
      "class sieve {",
      "  bitset<chunk> is_prime;",
      "  vector<int> pre_primes, add_primes;",
      "  vector<ll> primes = {2};",
      "",
      "public:",
      "  sieve() {",
      "    int sq = sqrt(n), pre = ((ll)sq * sq == n ? sq : sq + 1);",
      "    is_prime.set();",
      "    for(ll i = 2;i < pre;i++) if(is_prime[i]) {",
      "      pre_primes.push_back(i);",
      "      add_primes.push_back(i * 3);",
      "      for(ll j = i * i;j < pre;j += i) is_prime[j] = false;",
      "    }",
      "    for(ll i = 0;i <= n;i += chunk) {",
      "      is_prime.set();",
      "      is_prime[1] = i != 0;",
      "      for(int j = 1;j < pre_primes.size();j++) {",
      "        for(;add_primes[j] < chunk;add_primes[j] += pre_primes[j] * 2) is_prime[add_primes[j]] = false;",
      "        add_primes[j] -= chunk;",
      "      }",
      "      for(int j = 1;j < chunk;j += 2) {",
      "        if(i + j > n) break;",
      "        if(is_prime[j]) primes.push_back(i + j);",
      "      }",
      "    }",
      "  }",
      "",
      "  auto begin() { return primes.cbegin(); }",
      "  auto end() { return primes.cend(); }",
      "  ll operator[] (int i) { return primes[i - 1]; }",
      "  bool operator() (ll i) { return binary_search(primes.begin(), primes.end(), i); }",
      "  int count() {return primes.size(); }",
      "};",
      "",
      "// linear sieve",
      "// https://github.com/justiceHui/icpc-teamnote/blob/master/code/Math/LinearSieve.cpp"
    ],
    "description": "sieve.cpp template"
  },
  "const_rmq.cpp": {
    "prefix": "const_rmq.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class const_rmq {",
      "  const int sz, lg;",
      "  vector<vector<T>> arr;",
      "  Merge op;",
      "",
      "public:",
      "  template <typename I>",
      "  const_rmq(I s, I e) : sz(distance(s, e)), lg(__lg(sz)), arr(lg + 1, vector<T>(sz)) {",
      "    for(int i = 0;s != e;i++) arr[0][i] = *s++;",
      "    for(int i = 1;i <= lg;i++) for(int j = 0;j + (1 << i - 1) < sz;j++) arr[i][j] = op(arr[i - 1][j], arr[i - 1][j + (1 << i - 1)]);",
      "  }",
      "",
      "  T operator() (int l, int r) {",
      "    int d = __lg(r - l + 1);",
      "    T a = arr[d][l], b = arr[d][r - (1 << d) + 1];",
      "    return op(a, b);",
      "  }",
      "};"
    ],
    "description": "const_rmq.cpp template"
  },
  "merge_sort_tree.cpp": {
    "prefix": "merge_sort_tree.cpp",
    "body": [
      "template <typename T, typename Count>",
      "class merge_sort_tree {",
      "  const int sz;",
      "  vector<vector<T>> tree;",
      "  Count cnt;",
      "",
      "public:",
      "  template <typename I>",
      "  merge_sort_tree(I s, I e) : sz(1 << __lg(distance(s, e) * 2 - 1)), tree(sz * 2) {",
      "    for(int i = 0;s + i != e;i++) tree[i + sz].push_back(s[i]);",
      "    for(int i = sz;--i;) {",
      "      auto &l = tree[i * 2], &r = tree[i * 2 + 1];",
      "      tree[i].resize(l.size() + r.size());",
      "      merge(l.begin(), l.end(), r.begin(), r.end(), tree[i].begin());",
      "    }",
      "  }",
      "",
      "  int operator() (int l, int r, T k) {",
      "    l += sz; r += sz;",
      "    int s = 0;",
      "    for(;l <= r;l /= 2, r /= 2) {",
      "      if(l & 1) s += cnt(tree[l++], k);",
      "      if(~r & 1) s += cnt(tree[r--], k);",
      "    }",
      "    return s;",
      "  }",
      "};",
      "",
      "struct op {",
      "  int operator() (vector<int>& v, int k) {",
      "    return 0;",
      "  }",
      "};"
    ],
    "description": "merge_sort_tree.cpp template"
  },
  "mo's.cpp": {
    "prefix": "mo's.cpp",
    "body": [
      "// O((N+Q)√N)",
      "int sz = sqrt(n);",
      "",
      "struct query {",
      "  int l, r, idx;",
      "  bool operator < (const query& v) const {",
      "    if(l / sz != v.l / sz) return l / sz < v.l / sz;",
      "    return r < v.r;",
      "  }",
      "};",
      "",
      "//faster",
      "struct query {",
      "  int l, r, idx;",
      "  bool operator < (const query& v) const {",
      "    int a = l / sz, b = v.l / sz;",
      "    return (a < b) || ((a == b) && ((a & 1) ^ (r < v.r)));",
      "  }",
      "};",
      "",
      "int l = q[0].l, r = l - 1;",
      "for(int i = 0;i < m;i++) {",
      "  while(q[i].l < l) add(arr[--l]);",
      "  while(q[i].r > r) add(arr[++r]);",
      "  while(q[i].l > l) del(arr[l++]);",
      "  while(q[i].r < r) del(arr[r--]);",
      "  ans[q[i].idx] = tmp;",
      "}",
      "",
      "// O(N√Q) [An alternative sorting order for Mo's algorithm](https://codeforces.com/blog/entry/61203)",
      "struct query {",
      "  int l, r, idx;",
      "  int64_t ord = 0;",
      "  void operator() () {",
      "    int x = l, y = r;",
      "    int lg = __lg(max(x, y) * 2 + 1) | 1;",
      "    uint64_t maxn = (1ULL << lg) - 1;",
      "    for(uint64_t s = 1ULL << (lg - 1);s;s >>= 1) {",
      "      bool rx = x & s, ry = y & s;",
      "      ord = (ord << 2) | (rx ? ry ? 2 : 1 : ry ? 3 : 0);",
      "      if(rx) continue;",
      "      if(ry) x ^= maxn, y ^= maxn;",
      "      swap(x, y);",
      "    }",
      "  }",
      "  bool operator < (const query& v) const {",
      "    return ord < v.ord;",
      "  }",
      "};"
    ],
    "description": "mo's.cpp template"
  },
  "splay_tree.cpp": {
    "prefix": "splay_tree.cpp",
    "body": [
      "// https://justicehui.github.io/ps/2019/10/25/BOJ13159/",
      "// TODO",
      "",
      "template <typename T, typename Compare>",
      "class splay_tree {",
      "  struct node {",
      "    int l, r, p;",
      "    T v;",
      "    node(T &v) : v(v) {",
      "      l = r = p = -1;",
      "    }",
      "  };",
      "  int root;",
      "  vector<node> tree;",
      "  Compare cmp;",
      "",
      "  int append(T &v) {",
      "    tree.push_back(node(v));",
      "    return tree.size() - 1;",
      "  }",
      "",
      "  void rotate(int i) {",
      "    int p = tree[i].p, b = -1;",
      "    if(p == -1) return;",
      "    if(i == tree[p].l) {",
      "      tree[p].l = b = tree[i].r;",
      "      tree[i].r = p;",
      "    } else {",
      "      tree[p].r = b = tree[i].l;",
      "      tree[i].l = p;",
      "    }",
      "    tree[i].p = tree[p].p;",
      "    tree[p].p = i;",
      "    if(b != -1) tree[b].p = p;",
      "    if(tree[i].p != -1) {",
      "      if(p == tree[tree[i].p].l) tree[tree[i].p].l = i;",
      "      else tree[tree[i].p].r = i;",
      "    } else root = a;",
      "  }",
      "",
      "  void splay(int i) {",
      "    while(tree[i].p != -1) {",
      "      int p = tree[i].p, pp = tree[p].p;",
      "      if(pp != -1) {",
      "        if((i == tree[p].l) == (p == tree[pp].l)) rotate(p);",
      "        else rotate(i);",
      "      }",
      "      rotate(i);",
      "    }",
      "  }",
      "",
      "public:",
      "  splay_tree() {",
      "    root = append();",
      "  }",
      "",
      "  void insert(T v) {",
      "    ",
      "  }",
      "};"
    ],
    "description": "splay_tree.cpp template"
  },
  "sqrt_decomposition.cpp": {
    "prefix": "sqrt_decomposition.cpp",
    "body": [
      "// TODO"
    ],
    "description": "sqrt_decomposition.cpp template"
  },
  "fenwick_2d.cpp": {
    "prefix": "fenwick_2d.cpp",
    "body": [
      "template <typename T>",
      "class fenwick_2d {",
      "  const int n, m;",
      "  vector<vector<T>> tree;",
      "",
      "public:",
      "  fenwick_2d(int n, int m) : n(n), m(m), tree(n + 1, vector<T>(m + 1)) {}",
      "",
      "  void update(int i, int jj, T v) {",
      "    for(;i <= n;i += i & -i) for(int j = jj;j <= m;j += j & -j) tree[i][j] += v;",
      "  }",
      "",
      "  T operator() (int i, int jj) {",
      "    T s = 0;",
      "    for(;i;i -= i & -i) for(int j = jj;j;j -= j & -j) s += tree[i][j];",
      "    return s;",
      "  }",
      "  T operator() (int x1, int y1, int x2, int y2) {",
      "    return (*this)(x2, y2) - (*this)(x2, y1 - 1) - (*this)(x1 - 1, y2) + (*this)(x1 - 1, y1 - 1);",
      "  }",
      "};"
    ],
    "description": "fenwick_2d.cpp template"
  },
  "fenwick_tree-range_update.cpp": {
    "prefix": "fenwick_tree-range_update.cpp",
    "body": [
      "template <typename T>",
      "class fenwick_tree {",
      "  const int sz;",
      "  vector<T> tree;",
      "",
      "public:",
      "  fenwick_tree(int sz) : sz(sz), tree(sz + 1) {}",
      "",
      "  void update(int l, int r, T v) {",
      "    for(;l <= sz;l += l & -l) tree[l] += v;",
      "    for(r++;r <= sz;r += r & -r) tree[r] -= v;",
      "  }",
      "",
      "  T operator() (int i) {",
      "    T s = 0;",
      "    for(;i;i -= i & -i) s += tree[i];",
      "    return s;",
      "  }",
      "};"
    ],
    "description": "fenwick_tree-range_update.cpp template"
  },
  "fenwick_tree-two_way.cpp": {
    "prefix": "fenwick_tree-two_way.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class fenwick_tree {",
      "  const int sz;",
      "  const T raw;",
      "  vector<T> arr, tree1, tree2;",
      "  Merge op;",
      "",
      "public:",
      "  fenwick_tree(int sz, T raw = T()) : sz(sz), raw(raw), arr(sz + 1, raw), tree1(sz + 1, raw), tree2(sz + 1, raw) {}",
      "  ",
      "  void update(int i, T v) {",
      "    T tmp = arr[i] = v;",
      "    for(int j = i, l = i - 1, r = i + 1;j <= sz;j += j & -j) {",
      "      for(;l > j - (j & -j);l -= l & -l) tmp = op(tree1[l], tmp);",
      "      for(;r < j;r += r & -r) tmp = op(tmp, tree2[r]);",
      "      tree1[j] = i ^ j ? op(tmp, arr[j]) : tmp;",
      "    }",
      "    tmp = v;",
      "    for(int j = i, l = i - 1, r = i + 1;j;j -= j & -j) {",
      "      for(;l > j;l -= l & -l) tmp = op(tree1[l], tmp);",
      "      for(;r <= sz && r < j + (j & -j);r += r & -r) tmp = op(tmp, tree2[r]);",
      "      tree2[j] = i ^ j ? op(arr[j], tmp) : tmp;",
      "    }",
      "  }",
      "",
      "  T operator() (int l, int r) {",
      "    T s1 = raw, s2 = raw;",
      "    int i;",
      "    for(i = l;i + (i & -i) <= r;i += i & -i) s1 = op(s1, tree2[i]);",
      "    for(i = r;i - (i & -i) >= l;i -= i & -i) s2 = op(tree1[i], s2);",
      "    return op(op(s1, arr[i]), s2);",
      "  }",
      "};",
      "",
      "// TODO: with 2 array"
    ],
    "description": "fenwick_tree-two_way.cpp template"
  },
  "fenwick_tree.cpp": {
    "prefix": "fenwick_tree.cpp",
    "body": [
      "template <typename T>",
      "class fenwick_tree {",
      "  const int sz;",
      "  vector<T> tree;",
      "",
      "public:",
      "  fenwick_tree(int sz) : sz(sz), tree(sz + 1) {}",
      "",
      "  void update(int i, T v) {",
      "    for(;i <= sz;i += i & -i) tree[i] += v;",
      "  }",
      "",
      "  T operator() (int i) {",
      "    T s = 0;",
      "    for(;i;i -= i & -i) s += tree[i];",
      "    return s;",
      "  }",
      "  T operator() (int l, int r) {",
      "    return (*this)(r) - (*this)(l - 1);",
      "  }",
      "};"
    ],
    "description": "fenwick_tree.cpp template"
  },
  "lazy_fenwick_tree.cpp": {
    "prefix": "lazy_fenwick_tree.cpp",
    "body": [
      "template <typename T>",
      "class lazy_fenwick_tree {",
      "  using L = complex<T>;",
      "  const int sz;",
      "  vector<L> tree;",
      "",
      "public:",
      "  lazy_fenwick_tree(int sz) : sz(sz), tree(sz + 1) {}",
      "",
      "  void update(int l, int r, T v) {",
      "    for(int i = l;i <= sz;i += i & -i) tree[i] += L(v, -v * (l - 1));",
      "    for(int i = r + 1;i <= sz;i += i & -i) tree[i] += L(-v, v * r);",
      "  }",
      "",
      "  T operator() (int i) {",
      "    L s;",
      "    int st = i;",
      "    for(;i;i -= i & -i) s += tree[i];",
      "    return s.real() * st + s.imag();",
      "  }",
      "  T operator() (int l, int r) {",
      "    return (*this)(r) - (*this)(l - 1);",
      "  }",
      "};"
    ],
    "description": "lazy_fenwick_tree.cpp template"
  },
  "merge_sort_tree-fenwick_tree.cpp": {
    "prefix": "merge_sort_tree-fenwick_tree.cpp",
    "body": [
      "template <typename T, typename Count>",
      "class merge_sort_tree {",
      "  const int sz;",
      "  vector<vector<T>> tree;",
      "  Count cnt;",
      "",
      "public:",
      "  template <typename I>",
      "  merge_sort_tree(I s, I e) : sz(distance(s, e)), tree(sz + 1) {",
      "    for(int i = 0;i < sz;i++, s++) for(int j = i + 1;j <= sz;j += j & -j) tree[j].push_back(*s);",
      "    for(int i = 1;i <= sz;i++) sort(tree[i].begin(), tree[i].end());",
      "  }",
      "",
      "  int operator() (int i, T &k) {",
      "    int s = 0;",
      "    for(;i;i -= i & -i) s += cnt(tree[i], k);",
      "    return s;",
      "  }",
      "  int operator() (int l, int r, T k) {",
      "    return (*this)(r, k) - (*this)(l - 1, k);",
      "  }",
      "};",
      "",
      "struct op {",
      "  int operator() (vector<int>& v, int k) {",
      "    return 0;",
      "  }",
      "};"
    ],
    "description": "merge_sort_tree-fenwick_tree.cpp template"
  },
  "dynamic_segment_tree-with_pbds.cpp": {
    "prefix": "dynamic_segment_tree-with_pbds.cpp",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "// MLE 이슈 + TLE 이슈 = 쓰레기",
      "template <typename T, typename Merge>",
      "class dynamic_segment_tree {",
      "  const int sz = 1;",
      "  const T raw;",
      "  cc_hash_table<int, T> tree;",
      "  Merge op;",
      "",
      "  T get(int a) {",
      "    if(tree.find(a) != tree.end()) return tree[a];",
      "    return raw;",
      "  }",
      "",
      "public:",
      "  dynamic_segment_tree(int mx, T raw = T()) : sz(1 << __lg(mx * 2 - 1)), raw(raw) {}",
      "",
      "  void update(int a, T x) {",
      "    a += sz;",
      "    tree[a] = x;",
      "    while(a /= 2) tree[a] = op(get(a * 2), get(a * 2 + 1));",
      "  }",
      "",
      "  T query(int l, int r) {",
      "    l += sz; r += sz;",
      "    T s1 = raw, s2 = raw;",
      "    for(;l <= r;l /= 2, r /= 2) {",
      "      if(l & 1) s1 = op(s1, get(l++));",
      "      if(~r & 1) s2 = op(get(r--), s2);",
      "    }",
      "    return op(s1, s2);",
      "  }",
      "};"
    ],
    "description": "dynamic_segment_tree-with_pbds.cpp template"
  },
  "dynamic_segment_tree.cpp": {
    "prefix": "dynamic_segment_tree.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class dynamic_segment_tree {",
      "  const ll sz;",
      "  const T raw;",
      "  struct node {",
      "    int l, r;",
      "    T v;",
      "    node(const T& v) : l(-1), r(-1), v(v) {}",
      "  };",
      "  vector<node> tree;",
      "  Merge op;",
      "",
      "  int append() {",
      "    tree.push_back(node(raw));",
      "    return tree.size() - 1;",
      "  }",
      "",
      "  void update(int cur, ll s, ll e, ll i, T& v) {",
      "    if(i < s || e < i) return;",
      "    if(s == e) {",
      "      tree[cur].v += v;",
      "      return;",
      "    }",
      "    ll m = (s + e) / 2;",
      "    if(tree[cur].l == -1) tree[cur].l = append();",
      "    if(tree[cur].r == -1) tree[cur].r = append();",
      "    update(tree[cur].l, s, m, i, v);",
      "    update(tree[cur].r, m + 1, e, i, v);",
      "    tree[cur].v = op(tree[tree[cur].l].v, tree[tree[cur].r].v);",
      "  }",
      "",
      "  T query(int cur, ll s, ll e, ll l, ll r) {",
      "    if(cur == -1 || r < s || e < l) return raw;",
      "    if(l <= s && e <= r) return tree[cur].v;",
      "    ll m = (s + e) / 2;",
      "    return op(",
      "      query(tree[cur].l, s, m, l, r),",
      "      query(tree[cur].r, m + 1, e, l, r)",
      "    );",
      "  }",
      "",
      "public:",
      "  dynamic_segment_tree(ll mx, T raw = T()) : sz(mx + 1), raw(raw) {",
      "    append();",
      "  }",
      "",
      "  void update(ll i, T v) {",
      "    update(0, 0, sz - 1, i, v);",
      "  }",
      "",
      "  T operator() (ll l, ll r) {",
      "    return query(0, 0, sz - 1, l, r);",
      "  }",
      "};",
      "",
      "ll kth(int cur, ll s, ll e, T v) {",
      "  if(s == e) return s;",
      "  ll m = (s + e) / 2;",
      "  if(tree[tree[cur].l].v >= v) return kth(tree[cur].l, s, m, v);",
      "  else return kth(tree[cur].r, m + 1, e, v - tree[tree[cur].l].v);",
      "}",
      "",
      "ll kth(T k) {",
      "  return kth(0, 0, sz - 1, k);",
      "}"
    ],
    "description": "dynamic_segment_tree.cpp template"
  },
  "lazy_segment_tree.cpp": {
    "prefix": "lazy_segment_tree.cpp",
    "body": [
      "template <typename T, typename L, typename Merge, typename Update, typename Composition>",
      "class lazy_segment_tree {",
      "  const int lg, sz;",
      "  const T raw;",
      "  const L lazy_raw;",
      "  vector<T> tree;",
      "  vector<L> lazy;",
      "  Merge op;",
      "  Update upd;",
      "  Composition comp;",
      "",
      "  void apply(int i, L v) {",
      "    upd(tree[i], v);",
      "    if(i < sz) lazy[i] = comp(lazy[i], v);",
      "  }",
      "",
      "  void push(int i) {",
      "    apply(i * 2, lazy[i]);",
      "    apply(i * 2 + 1, lazy[i]);",
      "    lazy[i] = lazy_raw;",
      "  }",
      "",
      "  void pull(int i) {",
      "    tree[i] = op(tree[i * 2], tree[i * 2 + 1]);",
      "  }",
      "",
      "public:",
      "  lazy_segment_tree(int n, T raw = T(), L lazy_raw = L())",
      "  : lg(__lg(n * 2 - 1)), sz(1 << lg), raw(raw), lazy_raw(lazy_raw), tree(sz * 2, raw), lazy(sz, lazy_raw) {}",
      "",
      "  void set(int i, const T& v) {",
      "    tree[i + sz] = v;",
      "  }",
      "",
      "  void init() {",
      "    for(int i = sz;--i;) pull(i);",
      "  }",
      "",
      "  void update(int i, L v) {",
      "    i += sz;",
      "    for(int j = lg;j;j--) push(i >> j);",
      "    apply(i, v);",
      "    for(int j = 1;j <= lg;j++) pull(i >> j);",
      "  }",
      "  void update(int l, int r, L v) {",
      "    l += sz; r += sz;",
      "    for(int i = lg;i;i--) {",
      "      if(l >> i << i != l) push(l >> i);",
      "      if(r + 1 >> i << i != r + 1) push(r >> i);",
      "    }",
      "    for(int s = l, e = r;s <= e;s /= 2, e /= 2) {",
      "      if(s & 1) apply(s++, v);",
      "      if(~e & 1) apply(e--, v);",
      "    }",
      "    for(int i = 1;i <= lg;i++) {",
      "      if(l >> i << i != l) pull(l >> i);",
      "      if(r + 1 >> i << i != r + 1) pull(r >> i);",
      "    }",
      "  }",
      "",
      "  T operator() (int i) {",
      "    i += sz;",
      "    for(int j = lg;j;j--) push(i >> j);",
      "    return tree[i];",
      "  }",
      "  T operator() (int l, int r) {",
      "    l += sz; r += sz;",
      "    T s1 = raw, s2 = raw;",
      "    for(int i = lg;i;i--) {",
      "      if(l >> i << i != l) push(l >> i);",
      "      if(r + 1 >> i << i != r + 1) push(r >> i);",
      "    }",
      "    for(;l <= r;l /= 2, r /= 2) {",
      "      if(l & 1) s1 = op(s1, tree[l++]);",
      "      if(~r & 1) s2 = op(tree[r--], s2);",
      "    }",
      "    return op(s1, s2);",
      "  }",
      "};",
      "",
      "using ll = long long;",
      "using pii = pair<ll, int>;",
      "",
      "struct op {",
      "  pii operator() (pii a, pii b) {",
      "    return {a.first + b.first, a.second + b.second};",
      "  }",
      "};",
      "",
      "struct upd {",
      "  void operator() (pii& a, ll b) {",
      "    a.first += b * a.second;",
      "  }",
      "};",
      "",
      "struct comp {",
      "  ll operator() (ll a, ll b) {",
      "    return a + b;",
      "  }",
      "};",
      "",
      "/*",
      "`lazy_segment_tree<T, L, Merge, Update, Composition> seg(n, raw, lazy_raw)`",
      "",
      "* T : tree에 들어갈 타입",
      "* L : lazy에 들어갈 타입",
      "* Merge : `T operator() (T a, T b)`",
      "  * non-lazy한 값끼리 합치기",
      "* Update : `void operator() (T& a, L b)`",
      "  * non-lazy한 a에 lazy한 b를 적용",
      "* Composition : `L operator() (L a, L b)`",
      "  * lazy한 a에 lazy한 b 합치기",
      "*/"
    ],
    "description": "lazy_segment_tree.cpp template"
  },
  "persistent_segment_tree.cpp": {
    "prefix": "persistent_segment_tree.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class persistent_segment_tree {",
      "  const int sz;",
      "  const T raw;",
      "  struct node {",
      "    int l, r;",
      "    T v;",
      "    node(const T& v) : l(-1), r(-1), v(v) {}",
      "  };",
      "  vector<node> tree;",
      "  vector<int> root;",
      "  Merge op;",
      "",
      "  int append() {",
      "    tree.push_back(node(raw));",
      "    return tree.size() - 1;",
      "  }",
      "",
      "  void update(int prev, int cur, int s, int e, int i, T& v) {",
      "    if(cur == -1 || s > i || e < i) return;",
      "    if(s == e) {",
      "      tree[cur].v = op(tree[cur].v, v);",
      "      return;",
      "    }",
      "    if(tree[prev].l == -1) tree[prev].l = append();",
      "    if(tree[prev].r == -1) tree[prev].r = append();",
      "    int m = (s + e) / 2;",
      "    if(i <= m) {",
      "      int nxt = append();",
      "      tree[nxt] = tree[tree[prev].l];",
      "      tree[cur].l = nxt;",
      "      tree[cur].r = tree[prev].r;",
      "      update(tree[prev].l, tree[cur].l, s, m, i, v);",
      "    } else {",
      "      int nxt = append();",
      "      tree[nxt] = tree[tree[prev].r];",
      "      tree[cur].l = tree[prev].l;",
      "      tree[cur].r = nxt;",
      "      update(tree[prev].r, tree[cur].r, m + 1, e, i, v);",
      "    }",
      "    tree[cur].v = op(",
      "      tree[cur].l != -1 ? tree[tree[cur].l].v : raw,",
      "      tree[cur].r != -1 ? tree[tree[cur].r].v : raw",
      "    );",
      "  }",
      "",
      "  T query(int cur, int s, int e, int l, int r) {",
      "    if(cur == -1 || r < s || e < l) return raw;",
      "    if(l <= s && e <= r) return tree[cur].v;",
      "    int m = (s + e) / 2;",
      "    return op(query(tree[cur].l, s, m, l, r), query(tree[cur].r, m + 1, e, l, r));",
      "  }",
      "",
      "public:",
      "  persistent_segment_tree(int n, T raw = T()) : sz(n), raw(raw) {",
      "    root.push_back(append());",
      "  }",
      "",
      "  int update(int i, T v) {",
      "    int prev = root.back();",
      "    root.push_back(append());",
      "    update(prev, root.back(), 0, sz - 1, i, v);",
      "    return root.size() - 1;",
      "  }",
      "",
      "  T query(int ver, int l, int r) {",
      "    return query(root[ver], 0, sz - 1, l, r);",
      "  }",
      "};"
    ],
    "description": "persistent_segment_tree.cpp template"
  },
  "segment_tree.cpp": {
    "prefix": "segment_tree.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class segment_tree {",
      "  const int sz;",
      "  const T raw;",
      "  vector<T> tree;",
      "  Merge op;",
      "",
      "public:",
      "  segment_tree(int n, T raw = T()) : sz(1 << __lg(n * 2 - 1)), raw(raw), tree(sz * 2, raw) {}",
      "",
      "  void update(int i, T v) {",
      "    i += sz;",
      "    tree[i] = v;",
      "    while(i /= 2) tree[i] = op(tree[i * 2], tree[i * 2 + 1]);",
      "  }",
      "",
      "  T operator() (int i) {",
      "    return tree[i + sz];",
      "  }",
      "  T operator() (int l, int r) {",
      "    l += sz; r += sz;",
      "    T s1 = raw, s2 = raw;",
      "    for(;l <= r;l /= 2, r /= 2) {",
      "      if(l & 1) s1 = op(s1, tree[l++]);",
      "      if(~r & 1) s2 = op(tree[r--], s2);",
      "    }",
      "    return op(s1, s2);",
      "  }",
      "};",
      "",
      "// 추가",
      "void set(int i, T v) {",
      "  tree[i + sz] = v;",
      "}",
      "",
      "void init() {",
      "  for(int i = sz;--i;) tree[i] = op(tree[i * 2], tree[i * 2 + 1]);",
      "}",
      "",
      "int kth(int k) {",
      "  int s = 1;",
      "  while(s < sz) {",
      "    if(tree[s * 2] < k) {",
      "      k -= tree[s * 2];",
      "      s = s * 2 + 1;",
      "    } else s = s * 2;",
      "  }",
      "  return s - sz;",
      "}",
      "",
      "T top() {",
      "  return tree[1];",
      "}",
      "",
      "// 최대 구간합",
      "struct hoit {",
      "  int p, l, r, a;",
      "};",
      "",
      "struct op {",
      "  hoit operator() (hoit& a, hoit& b) {",
      "    hoit tmp;",
      "    tmp.p = max({a.r + b.l, a.p, b.p});",
      "    tmp.l = max(a.l, a.a + b.l);",
      "    tmp.r = max(a.r + b.a, b.r);",
      "    tmp.a = a.a + b.a;",
      "    return tmp;",
      "  }",
      "};"
    ],
    "description": "segment_tree.cpp template"
  },
  "segment_tree_2d.cpp": {
    "prefix": "segment_tree_2d.cpp",
    "body": [
      "template <typename T, typename Merge>",
      "class segment_tree_2d {",
      "  const int sz;",
      "  const T raw;",
      "  vector<vector<T>> tree;",
      "  Merge op;",
      "",
      "  T query(int x, int y1, int y2) {",
      "    T s = raw;",
      "    for(;y1 <= y2;y1 /= 2, y2 /= 2) {",
      "      if(y1 & 1) s = op(s, tree[x][y1++]);",
      "      if(~y2 & 1) s = op(s, tree[x][y2--]);",
      "    }",
      "    return s;",
      "  }",
      "",
      "public:",
      "  segment_tree_2d(int n, T raw = T()) : sz(1 << __lg(n * 2 - 1)), raw(raw), tree(sz * 2, vector<T>(raw)) {}",
      "",
      "  void update(int i, int jj, T v) {",
      "    i += sz; jj += sz;",
      "    tree[i][jj] = v;",
      "    for(int j = jj;j /= 2;) tree[i][j] = op(tree[i][j * 2], tree[i][j * 2 + 1]);",
      "    while(i /= 2) for(int j = jj;j;j /= 2) tree[i][j] = op(tree[i * 2][j], tree[i * 2 + 1][j]);",
      "  }",
      "",
      "  T operator() (int x1, int y1, int x2, int y2) {",
      "    x1 += sz; y1 += sz; x2 += sz; y2 += sz;",
      "    T s = raw;",
      "    for(;x1 <= x2;x1 /= 2, x2 /= 2) {",
      "      if(x1 & 1) s = op(s, query(x1++, y1, y2));",
      "      if(~x2 & 1) s = op(s, query(x2--, y1, y2));",
      "    }",
      "    return s;",
      "  }",
      "};",
      "",
      "void set(int i, int j, T v) {",
      "  tree[i + sz][j + sz] = v;",
      "}",
      "",
      "void init() {",
      "  for(int i = sz;i < sz * 2;i++) for(int j = sz;--j;) tree[i][j] = op(tree[i][j * 2], tree[i][j * 2 + 1]);",
      "  for(int i = sz;--i;) for(int j = 1;j < sz * 2;j++) tree[i][j] = op(tree[i * 2][j], tree[i * 2 + 1][j]);",
      "}"
    ],
    "description": "segment_tree_2d.cpp template"
  },
  "segment_tree_beats.cpp": {
    "prefix": "segment_tree_beats.cpp",
    "body": [
      "template <typename T, typename L, typename Merge, typename Update, typename Composition>",
      "class segment_tree_beats {",
      "  const int lg, sz;",
      "  const T raw;",
      "  const L lazy_raw;",
      "  vector<T> tree;",
      "  vector<L> lazy;",
      "  Merge op;",
      "  Update try_upd;",
      "  Composition comp;",
      "",
      "  void apply(int i, L v) {",
      "    bool fail = try_upd(tree[i], v);",
      "    if(i < sz) {",
      "      lazy[i] = comp(lazy[i], v);",
      "      if(fail) {",
      "        push(i);",
      "        pull(i);",
      "      }",
      "    }",
      "  }",
      "",
      "  void push(int i) {",
      "    apply(i * 2, lazy[i]);",
      "    apply(i * 2 + 1, lazy[i]);",
      "    lazy[i] = lazy_raw;",
      "  }",
      "",
      "  void pull(int i) {",
      "    tree[i] = op(tree[i * 2], tree[i * 2 + 1]);",
      "  }",
      "",
      "public:",
      "  segment_tree_beats(int n, T raw = T(), L lazy_raw = L())",
      "  : lg(__lg(n * 2 - 1)), sz(1 << lg), raw(raw), lazy_raw(lazy_raw), tree(sz * 2, raw), lazy(sz, lazy_raw) {}",
      "",
      "  void set(int i, T v) {",
      "    tree[i + sz] = v;",
      "  }",
      "",
      "  void init() {",
      "    for(int i = sz;--i;) pull(i);",
      "  }",
      "",
      "  void update(int i, L v) {",
      "    i += sz;",
      "    for(int j = lg;j;j--) push(i >> j);",
      "    apply(i, v);",
      "    for(int j = 1;j <= lg;j++) pull(i >> j);",
      "  }",
      "  void update(int l, int r, L v) {",
      "    l += sz; r += sz;",
      "    for(int i = lg;i;i--) {",
      "      if(l >> i << i != l) push(l >> i);",
      "      if(r + 1 >> i << i != r + 1) push(r >> i);",
      "    }",
      "    for(int s = l, e = r;s <= e;s /= 2, e /= 2) {",
      "      if(s & 1) apply(s++, v);",
      "      if(~e & 1) apply(e--, v);",
      "    }",
      "    for(int i = 1;i <= lg;i++) {",
      "      if(l >> i << i != l) pull(l >> i);",
      "      if(r + 1 >> i << i != r + 1) pull(r >> i);",
      "    }",
      "  }",
      "",
      "  T operator() (int i) {",
      "    i += sz;",
      "    for(int j = lg;j;j--) push(i >> j);",
      "    return tree[i];",
      "  }",
      "  T operator() (int l, int r) {",
      "    l += sz; r += sz;",
      "    T s1 = raw, s2 = raw;",
      "    for(int i = lg;i;i--) {",
      "      if(l >> i << i != l) push(l >> i);",
      "      if(r + 1 >> i << i != r + 1) push(r >> i);",
      "    }",
      "    for(;l <= r;l /= 2, r /= 2) {",
      "      if(l & 1) s1 = op(s1, tree[l++]);",
      "      if(~r & 1) s2 = op(tree[r--], s2);",
      "    }",
      "    return op(s1, s2);",
      "  }",
      "};",
      "",
      "",
      "//수쿼 26",
      "using ll = long long;",
      "",
      "struct hoit {",
      "  ll max1, max2, sum;",
      "  int cnt;",
      "};",
      "",
      "struct op {",
      "  hoit operator() (hoit& a, hoit& b) {",
      "    hoit tmp;",
      "    tmp.sum = a.sum + b.sum;",
      "    tmp.max1 = max(a.max1, b.max1);",
      "    if(a.max1 < b.max1) {",
      "      tmp.cnt = b.cnt;",
      "      tmp.max2 = max(b.max2, a.max1);",
      "    } else if(a.max1 > b.max1) {",
      "      tmp.cnt = a.cnt;",
      "      tmp.max2 = max(a.max2, b.max1);",
      "    } else {",
      "      tmp.cnt = a.cnt + b.cnt;",
      "      tmp.max2 = max(a.max2, b.max2);",
      "    }",
      "    return tmp;",
      "  }",
      "};",
      "",
      "struct try_upd {",
      "  bool operator() (hoit& a, ll& b) {",
      "    if(b >= a.max1) {}",
      "    else if(b > a.max2) {",
      "      a.sum -= (a.max1 - b) * a.cnt;",
      "      a.max1 = b;",
      "    } else return true;",
      "    return false;",
      "  }",
      "};",
      "",
      "struct comp {",
      "  ll operator() (ll a, ll b) {",
      "    return min(a, b);",
      "  }",
      "};"
    ],
    "description": "segment_tree_beats.cpp template"
  },
  "sparse_segment_tree.cpp": {
    "prefix": "sparse_segment_tree.cpp",
    "body": [
      "template <typename T, typename L, typename Merge, typename Update, typename Composition>",
      "class sparse_segment_tree {",
      "  const int sz;",
      "  const T raw;",
      "  const L lazy_raw;",
      "  struct node {",
      "    int l, r;",
      "    T v;",
      "    L lazy;",
      "    node(const T &a, const L &b) : l(-1), r(-1), v(a), lazy(b) {}",
      "  };",
      "  vector<node> tree;",
      "  Merge op;",
      "  Update upd;",
      "  Composition comp;",
      "",
      "  int append() {",
      "    tree.push_back(node(raw, lazy_raw));",
      "    return tree.size() - 1;",
      "  }",
      "",
      "  void push(int cur, int s, int e) {",
      "    if(cur == -1 || tree[cur].lazy == lazy_raw) return;",
      "    upd(tree[cur].v, tree[cur].lazy, e - s + 1);",
      "    if(s != e) {",
      "      if(tree[cur].l == -1) tree[cur].l = append();",
      "      if(tree[cur].r == -1) tree[cur].r = append();",
      "      tree[tree[cur].l].lazy = comp(tree[tree[cur].l].lazy, tree[cur].lazy);",
      "      tree[tree[cur].r].lazy = comp(tree[tree[cur].r].lazy, tree[cur].lazy);",
      "    }",
      "    tree[cur].lazy = lazy_raw;",
      "  }",
      "",
      "  void update(int cur, int s, int e, int l, int r, L& v) {",
      "    push(cur, s, e);",
      "    if(r < s || e < l) return;",
      "    if(l <= s && e <= r) {",
      "      tree[cur].lazy = comp(tree[cur].lazy, v);",
      "      push(cur, s, e);",
      "      return;",
      "    }",
      "    int m = (s + e) / 2;",
      "    if(tree[cur].l == -1) tree[cur].l = append();",
      "    if(tree[cur].r == -1) tree[cur].r = append();",
      "    update(tree[cur].l, s, m, l, r, v);",
      "    update(tree[cur].r, m + 1, e, l, r, v);",
      "    tree[cur].v = op(tree[tree[cur].l].v, tree[tree[cur].r].v);",
      "  }",
      "",
      "  T query(int cur, int s, int e, int l, int r) {",
      "    if(cur == -1 || r < s || e < l) return raw;",
      "    push(cur, s, e);",
      "    if(l <= s && e <= r) return tree[cur].v;",
      "    int m = (s + e) / 2;",
      "    return op(",
      "      query(tree[cur].l, s, m, l, r),",
      "      query(tree[cur].r, m + 1, e, l, r)",
      "    );",
      "  }",
      "",
      "public:",
      "  sparse_segment_tree(int mx, T raw = T(), L lazy_raw = L()) : sz(mx + 1), raw(raw), lazy_raw(lazy_raw) {",
      "    append();",
      "  }",
      "",
      "  void update(int l, int r, L v) {",
      "    update(0, 0, sz - 1, l, r, v);",
      "  }",
      "",
      "  T operator() (int l, int r) {",
      "    return query(0, 0, sz - 1, l, r);",
      "  }",
      "};",
      "",
      "struct op {",
      "  ll operator() (ll a, ll b) {",
      "    return a + b;",
      "  }",
      "};",
      "",
      "struct upd {",
      "  void operator() (ll &a, ll b, int cnt) {",
      "    a += b * cnt;",
      "  }",
      "};",
      "",
      "struct comp {",
      "  ll operator() (ll a, ll b) {",
      "    return a + b;",
      "  }",
      "};"
    ],
    "description": "sparse_segment_tree.cpp template"
  },
  "bitset_operation.cpp": {
    "prefix": "bitset_operation.cpp",
    "body": [
      "// https://gist.github.com/cgiosy/a441de545c9e96b1d7b02cc7a00561f9",
      "",
      "#define private public",
      "#include <bitset>",
      "#undef private",
      "#include <x86intrin.h>",
      "",
      "template<size_t _Nw> void _M_do_sub(_Base_bitset<_Nw>& A, const _Base_bitset<_Nw>& B) {",
      "  for(int i = 0, c = 0;i < _Nw;i++)",
      "    c = _subborrow_u64(c, A._M_w[i], B._M_w[i], (unsigned long long*) & A._M_w[i]);",
      "}",
      "template<> void _M_do_sub(_Base_bitset<1>& A, const _Base_bitset<1>& B) {",
      "  A._M_w -= B._M_w;",
      "}",
      "template<size_t _Nb> bitset<_Nb>& operator-=(bitset<_Nb>& A, const bitset<_Nb>& B) {",
      "  _M_do_sub(A, B);",
      "  return A;",
      "}",
      "template<size_t _Nb> inline bitset<_Nb> operator-(const bitset<_Nb>& A, const bitset<_Nb>& B) {",
      "  bitset<_Nb> C(A);",
      "  return C -= B;",
      "}",
      "",
      "",
      "template<size_t _Nw> void _M_do_add(_Base_bitset<_Nw>& A, const _Base_bitset<_Nw>& B) {",
      "  for(int i = 0, c = 0;i < _Nw;i++)",
      "    c = _addcarry_u64(c, A._M_w[i], B._M_w[i], (unsigned long long*) & A._M_w[i]);",
      "}",
      "template<> void _M_do_add(_Base_bitset<1>& A, const _Base_bitset<1>& B) {",
      "  A._M_w += B._M_w;",
      "}",
      "template<size_t _Nb> bitset<_Nb>& operator+=(bitset<_Nb>& A, const bitset<_Nb>& B) {",
      "  _M_do_add(A, B);",
      "  return A;",
      "}",
      "template<size_t _Nb> inline bitset<_Nb> operator+(const bitset<_Nb>& A, const bitset<_Nb>& B) {",
      "  bitset<_Nb> C(A);",
      "  return C += B;",
      "}"
    ],
    "description": "bitset_operation.cpp template"
  },
  "hashing.cpp": {
    "prefix": "hashing.cpp",
    "body": [
      "template <int P, int M>",
      "class hashing {",
      "  const int sz;",
      "  vector<int> arr, _pow;",
      "",
      "public:",
      "  template <typename I>",
      "  hashing(I s, I e) : sz(distance(s, e)), arr(sz + 1), _pow(sz + 1) {",
      "    _pow[0] = 1;",
      "    for(int i = 1;i <= sz;i++) {",
      "      arr[i] = ((ll)arr[i - 1] * P + *s++) % M;",
      "      _pow[i] = (ll)_pow[i-1] * P % M;",
      "    }",
      "  }",
      "  ll operator() (int s, int e) {",
      "    s++; e++;",
      "    return ((arr[e] - (ll)arr[s - 1] * _pow[e - s + 1]) % M + M) % M;",
      "  }",
      "};",
      "",
      "// 1e9+7, 1'234'567'891, (1LL<<63)-25"
    ],
    "description": "hashing.cpp template"
  },
  "kmp.cpp": {
    "prefix": "kmp.cpp",
    "body": [
      "vector<int> pidx(string_view p) {",
      "  vector<int> pi(p.size());",
      "  for(int i = 1, j = 0;i < p.size();i++) {",
      "    while(j && p[i] != p[j]) j = pi[j - 1];",
      "    if(p[i] == p[j]) pi[i] = ++j;",
      "  }",
      "  return pi;",
      "}",
      "",
      "vector<int> kmp(string_view s, string_view p) {",
      "  vector<int> pi = pidx(p), match;",
      "  for(int i = 0, j = 0;i < s.size();i++) {",
      "    while(j && s[i] != p[j]) j = pi[j - 1];",
      "    if(s[i] != p[j]) continue;",
      "    if(j == p.size() - 1) {",
      "      match.push_back(i - j);",
      "      j = pi[j];",
      "    } else j++;",
      "  }",
      "  return match;",
      "}",
      "",
      "class kmp {",
      "  const int ssz, psz;",
      "  vector<int> pi;",
      "",
      "public:",
      "  vector<int> match;",
      "",
      "  template <typename I>",
      "  kmp(I s, I se, I p, I pe) : ssz(distance(s, se)), psz(distance(p, pe)), pi(psz) {",
      "    for(int i = 1, j = 0;i < psz;i++) {",
      "      while(j && p[i] != p[j]) j = pi[j - 1];",
      "      if(p[i] == p[j]) pi[i] = ++j;",
      "    }",
      "    for(int i = 0, j = 0;i < ssz;i++) {",
      "      while(j && s[i] != p[j]) j = pi[j - 1];",
      "      if(s[i] != p[j]) continue;",
      "      if(j == psz - 1) {",
      "        match.push_back(i - j);",
      "        j = pi[j];",
      "      } else j++;",
      "    }",
      "  }",
      "};"
    ],
    "description": "kmp.cpp template"
  },
  "manacher.cpp": {
    "prefix": "manacher.cpp",
    "body": [
      "template <typename T, typename I>",
      "vector<int> manacher(I s, I e) {",
      "  int sz = distance(s, e) * 2 + 1;",
      "  vector<T> str(sz);",
      "  vector<int> arr(sz);",
      "  for(int i = 1;s != e;i += 2) str[i] = *s++;",
      "  int m = 0, r = 0;",
      "  for(int i = 0;i < sz;i++) {",
      "    int l = m * 2 - i;",
      "    if(i < r) arr[i] = min(r - i, arr[l]);",
      "    while(i - arr[i] - 1 >= 0 && i + arr[i] + 1 < sz && str[i - arr[i] - 1] == str[i + arr[i] + 1]) arr[i]++;",
      "    if(i + arr[i] > r) {",
      "      m = i;",
      "      r = i + arr[i];",
      "    }",
      "  }",
      "  return arr;",
      "}"
    ],
    "description": "manacher.cpp template"
  },
  "suffix_array.cpp": {
    "prefix": "suffix_array.cpp",
    "body": [
      "// O(N log^2 N)",
      "class suffix_array {",
      "  const int sz;",
      "",
      "public:",
      "  vector<int> pos, suf, lcp;",
      "",
      "  template <typename I>",
      "  suffix_array(I s, I e) : sz(distance(s, e)), pos(s, e), suf(sz), lcp(sz) {",
      "    iota(suf.begin(), suf.end(), 0);",
      "    for(int i = 1;i < sz;i *= 2) {",
      "      auto cmp = [&](int a, int b) {",
      "        if(pos[a] != pos[b]) return pos[a] < pos[b];",
      "        a += i; b += i;",
      "        return (a < sz && b < sz) ? (pos[a] < pos[b]) : (a > b);",
      "      };",
      "      sort(suf.begin(), suf.end(), cmp);",
      "      vector<int> tmp(sz);",
      "      for(int j = 1;j < sz;j++) tmp[j] = tmp[j - 1] + cmp(suf[j - 1], suf[j]);",
      "      for(int j = 0;j < sz;j++) pos[suf[j]] = tmp[j];",
      "      if(tmp[sz - 1] == sz - 1) break;",
      "    }",
      "    for(int i = 0, j = 0;i < sz;i++) {",
      "      if(pos[i]) {",
      "        while(s[i + j] == s[suf[pos[i] - 1] + j]) j++;",
      "        lcp[pos[i]] = j;",
      "        j = max(0, j - 1);",
      "      } else lcp[pos[i]] = -1;",
      "    }",
      "  }",
      "};",
      "",
      "// O(N log N)",
      "class suffix_array {",
      "  const int sz;",
      "",
      "public:",
      "  vector<int> pos, suf, lcp;",
      "",
      "  template <typename I>",
      "  suffix_array(I s, I e) : sz(distance(s, e)), pos(s, e), suf(sz), lcp(sz) {",
      "    iota(suf.begin(), suf.end(), 0);",
      "    auto rank = [&](int i) { return i < sz ? pos[i] + 1 : 0; };",
      "    for(int i = 1;i < sz;i *= 2) {",
      "      vector<int> tmp(sz), cnt(max(sz, 256));",
      "      for(int j = 0;j < sz;j++) cnt[rank(suf[j] + i)]++;",
      "      for(int j = 1;j < cnt.size();j++) cnt[j] += cnt[j - 1];",
      "      for(int j = sz;j--;) tmp[--cnt[rank(suf[j] + i)]] = suf[j];",
      "      fill(cnt.begin(), cnt.end(), 0);",
      "      for(int j = 0;j < sz;j++) cnt[rank(tmp[j])]++;",
      "      for(int j = 1;j < cnt.size();j++) cnt[j] += cnt[j - 1];",
      "      for(int j = sz;j--;) suf[--cnt[rank(tmp[j])]] = tmp[j];",
      "      tmp[suf[0]] = 0;",
      "      for(int j = 1;j < sz;j++) tmp[suf[j]] = tmp[suf[j - 1]] + (rank(suf[j]) != rank(suf[j - 1]) || rank(suf[j] + i) != rank(suf[j - 1] + i));",
      "      pos = tmp;",
      "      if(pos[suf[sz - 1]] == sz - 1) break;",
      "    }",
      "    for(int i = 0, j = 0;i < sz;i++) {",
      "      if(pos[i]) {",
      "        while(s[i + j] == s[suf[pos[i] - 1] + j]) j++;",
      "        lcp[pos[i]] = j;",
      "        if(j > 0) j--;",
      "      } else lcp[pos[i]] = -1;",
      "    }",
      "  }",
      "};",
      "",
      "// https://gist.github.com/koosaga/44532e5dec947132ee55da0458255e05"
    ],
    "description": "suffix_array.cpp template"
  },
  "trie.cpp": {
    "prefix": "trie.cpp",
    "body": [
      "struct trie {",
      "  vector<pair<char, trie>> arr;",
      "  bool have = false;",
      "",
      "  trie() { }",
      "",
      "  trie* child(char c) {",
      "    for(auto& [k, v] : arr) if(k == c) return &v;",
      "    return nullptr;",
      "  }",
      "",
      "  template <typename I>",
      "  void insert(I s, I e) {",
      "    trie* cur = this;",
      "    for(;s != e;s++) {",
      "      trie* nxt = cur->child(*s);",
      "      if(nxt == nullptr) {",
      "        cur->arr.push_back({*s, trie()});",
      "        nxt = &cur->arr.back().second;",
      "      }",
      "      cur = nxt;",
      "    }",
      "    cur->have = true;",
      "  }",
      "};",
      "",
      "struct trie {",
      "  map<char, trie*> arr;",
      "  bool have = false;",
      "",
      "  trie() { }",
      "",
      "  trie* child(char c) {",
      "    if(auto it = arr.find(c);it != arr.end()) return it->second;",
      "    return nullptr;",
      "  }",
      "",
      "  template <typename I>",
      "  void insert(I s, I e) {",
      "    trie* cur = this;",
      "    for(;s != e;s++) {",
      "      trie* nxt = cur->child(*s);",
      "      if(nxt == nullptr) {",
      "        trie* tmp = new trie();",
      "        cur->arr[*s] = tmp;",
      "        nxt = tmp;",
      "      }",
      "      cur = nxt;",
      "    }",
      "    cur->have = true;",
      "  }",
      "};"
    ],
    "description": "trie.cpp template"
  },
  "aho_corasick.cpp": {
    "prefix": "aho_corasick.cpp",
    "body": [
      "struct aho_corasick {",
      "  map<char, aho_corasick*> arr;",
      "  aho_corasick* fail = nullptr;",
      "  int have = 0;",
      "",
      "  aho_corasick() { }",
      "  ~aho_corasick() {",
      "    for(auto [c, nxt] : arr) delete nxt;",
      "  }",
      "",
      "  aho_corasick* child(char c) {",
      "    if(auto it = arr.find(c);it != arr.end()) return it->second;",
      "    return nullptr;",
      "  }",
      "",
      "  template <typename I>",
      "  void insert(I s, I e) {",
      "    aho_corasick* cur = this;",
      "    for(;s != e;s++) {",
      "      aho_corasick* nxt = cur->child(*s);",
      "      if(nxt == nullptr) {",
      "        aho_corasick* tmp = new aho_corasick();",
      "        cur->arr[*s] = tmp;",
      "        nxt = tmp;",
      "      }",
      "      cur = nxt;",
      "    }",
      "    cur->have++;",
      "  }",
      "",
      "  void init() {",
      "    queue<aho_corasick*> q;",
      "    q.push(this);",
      "    while(q.size()) {",
      "      aho_corasick *cur = q.front();",
      "      q.pop();",
      "      for(auto [c, nxt] : cur->arr) {",
      "        if(cur == this) nxt->fail = this;",
      "        else {",
      "          aho_corasick *dest = cur->fail;",
      "          while(dest != this && !dest->child(c)) dest = dest->fail;",
      "          if(dest->child(c)) dest = dest->child(c);",
      "          else dest = this;",
      "          nxt->fail = dest;",
      "        }",
      "        nxt->have += nxt->fail->have;",
      "        q.push(nxt);",
      "      }",
      "    }",
      "  }",
      "",
      "  template <typename I>",
      "  int count(I s, I e) {",
      "    int tmp = 0;",
      "    aho_corasick *cur = this;",
      "    for(;s != e;s++) {",
      "      aho_corasick *nxt = cur->child(*s);",
      "      while(cur != this && !nxt) {",
      "        cur = cur->fail;",
      "        nxt = cur->child(*s);",
      "      }",
      "      if(nxt) cur = nxt;",
      "      tmp += cur->have;",
      "    }",
      "    return tmp;",
      "  }",
      "};"
    ],
    "description": "aho_corasick.cpp template"
  }
}